# C语言刷题

## 第一天

### 1.第一题

在 32 位编译器上，设有定义

```c
char *str1 = "Hello", str2[] = "Hello"; 
```

则以下语句

```c
 printf("%d %d", sizeof(str1), sizeof(str2)); 
```

的输出结果是（）

解答：本题主要考查了指向字符串的指针和字符数组， str1 为一个字符指针，所以 sizeof 为 4 ， str2 为字符数组，其中包含 6 个字符，所以答案为 4 6 。

知识点：指向 `char` 的指针（`char *`）的大小取决于系统架构。在大多数现代系统中，通常是 8 字节（在 64 位系统上）或 4 字节（在 32 位系统上）。

### 2.第二题

```c
unsigned int a = 0x1234;unsigned char b = *(unsigned char *)&a; 
```

在 32 位大端模式处理器上变量 b 等于（）

解答：unsigned int a = 0x1234; 其中 int 是 4 字节, 大端存储，补齐 16 进制表示为: 0x00 00 12 34unsigned char b = *(unsigned char *)&a; 由于大端存储，所以上述 int a 变量的最低地址存储的是十六进制表示中最左边的 1 字节为 0x00。

知识点：需要了解大端模式（Big-Endian）和小端模式（Little-Endian）的概念。在大端模式下，数据的高字节存储在内存的低地址，而低字节存储在高地址。相反，在小端模式下，低字节存储在低地址，高字节存储在高地址。

最高有效字节（Most Significant Byte，MSB）是指多字节数据中具有最高权重的字节。换句话说，在一个多字节的数据表示中，最高有效字节是数值最重要的字节，因为它包含了数据的最高位。

具体示例

考虑一个32位（4字节）的无符号整数 `0x12345678`，每个字节可以用两个十六进制数字表示：

- `0x12`
- `0x34`
- `0x56`
- `0x78`

在这个例子中：

- 最高有效字节（MSB）是 `0x12`。
- 最低有效字节（LSB）是 `0x78`。

最高有效字节在数据的最高位置，它对整个数值的影响最大。例如，改变 `0x12` 会显著改变整个数值，而改变 `0x78` 的影响相对较小。

### 大端存储和小端存储

了解了最高有效字节后，我们可以更好地理解大端存储和小端存储的区别。

#### 大端存储（Big-Endian）

在大端存储模式下，数据的最高有效字节存储在内存的最低地址。

### 内存的低地址和高地址

- **低地址（Low Address）**：低地址指的是内存中地址数值较小的位置。在一个连续的内存地址空间中，低地址位于起始端。
- **高地址（High Address）**：高地址指的是内存中地址数值较大的位置。在同一段连续的内存地址空间中，高地址位于结束端。

### 3.第三题

已知一函数中有下列变量定义，其中属于自动变量的有（）。

A

double k;

B

register int i;

C

static char c;

D

auto long m;

解答： 自动变量，只在定义它们的时候才创建，在定义它们的函数返回时系统回收变量所占 存储空间 。对这些变量存储空间的分配和回收是由系统自动完成的。一般情况下，不作专门说明的局部变量 ，均是自动变量。自动变量也可用关键字auto作出说明答案为AD

## 第二天

### 1.第一题

下列关于内存分配和释放的函数及其区别描述正确的有？

A

C++语言的标准内存分配函数：malloc，calloc，realloc，free等。

B

C语言的标准内存分配函数为new/delete。

C

malloc和calloc的区别是1块与n块的区别和初始化

D

realloc调用形式为(类型*)realloc(*ptr，size)：将ptr内存大小扩容到size。

解答：CD 

malloc，calloc，realloc，free属于C函数库，而new/delete则是C++函数库； 

### 2.第二题

下面有关C++的类和C里面的struct的描述，正确的有？

A

在C++中，来自class的继承默认按照private继承处理，来自struct的继承默认按照public继承处理

B

class的成员默认是private权限，struct默认是public权限

C

c里面的struct只是变量的聚合体，struct不能有函数

D

c++的struct可有构造和析构函数

解答：

1.在C++中，`struct`和`class`之间的主要区别在于默认的访问控制权限：`struct`中的成员默认是公有的（public），而`class`中的成员默认是私有的（private）。除了这个区别之外，`struct`和`class`在其他方面几乎是等价的。这意味着`struct`可以包含构造函数、析构函数、成员函数、运算符重载等。

2.c++中，class和struct的区别:
     a.成员访问权限->class的成员访问权限为private,而struct的成员访问权限为public
     b.默认的继承方式->class的默认继承方式为private,而struct的默认继承方式为public

3.struct在C和C++之间的区别
     a.c中，struct是用户自定义数据类型，而c++中，struct是抽象数据类型，支持成员定义函数；
     b.c中的struct是没有权限设置的，但是在c++中，给strcut添加了权限设置，增加了访问权限；
     c.c中的struct只是变量的聚合体，可以封装数据，但是不可以隐藏，不可以定义函数成员；但是C++中的struct可以定义函数成员

### 3.第三题

若有int i=10,j=0;则执行完语句

`if(j = 0)i++; else i--;i`的值为11。说法是否正确？

解答：错误，=和==不一样

### 4.第四题

C 语言源程序文件的缺省扩展名为 ( )

A

cpp

B

exe

C

obj

D

C

解答：在C语言中，源程序文件的缺省扩展名为 `.c`。

选项分析

A. `cpp`：

- 这是C++源文件的扩展名，不是C语言的扩展名。

B. `exe`：

- 这是可执行文件的扩展名，表示已经编译和链接后的可执行文件，不是源代码文件。

C. `obj`：

- 这是目标文件的扩展名，表示编译后的中间文件，不是源代码文件。

D. `c`：

- 这是C语言源文件的扩展名，表示C语言的源代码文件。

### 5.第五题

下列程序段的输出结果是（）

```C
double d = 3.2;int x, y;x = 1.2;y = (x + 3.8)/5.0;printf("%d\n", d*y);
```

A

3

B

3.2

C

0

D

3.07

解答：

分析每个步骤

1. **初始化和赋值**

```c
double d = 3.2;
```

变量 `d` 被初始化为 `3.2`。

```c
int x, y;
x = 1.2;
```

由于 `x` 是 `int` 类型，`1.2` 会被截断为 `1`，所以 `x` 的值为 `1`。

1. **计算 `y`**

```c
y = (x + 3.8) / 5.0;
```

首先计算括号内的表达式：

```c
x + 3.8 = 1 + 3.8 = 4.8
```

然后计算除法：

```c
4.8 / 5.0 = 0.96
```

由于 `y` 是 `int` 类型，`0.96` 会被截断为 `0`，所以 `y` 的值为 `0`。

1. **计算并打印结果**

```c
printf("%d\n", d * y);
```

计算 `d * y`：

```c
3.2 * 0 = 0.0
```

`printf` 的格式说明符 `%d` 用于打印整数，而此时我们试图打印一个浮点数的结果（虽然结果是 `0.0`，但还是浮点数）。

然而，因为 `y` 为 `0`，`d * y` 也为 `0`，所以打印的整数值是 `0`。

### 6.第六题

有如下程序段：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main() {  
    char a[] = "xyz", b[] = {'x', 'y', 'z'};  	  if (strlen(a) > strlen(b))    	 			printf("a > b\n");  
    else    		
        printf("a <= b\n");   
    return (0);
}
```



则程序输出：

A

a>b

B

a<=b

C

编译不通过

D

以上都不对

解答：

char a[] = "xyz", b[] = {'x', 'y', 'z'}; a容易理解，strlen(a)=3; b是数组，元素在内存中是连续存储的，而strlen函数求字符串长度是要以'\0'结尾，但是b没有'\0', strlen的内部函数指针会一直向后搜索，直至找到'\0',内存中的其他区域也是有数据的，只是没有意义， 所以，strlen的指针最后指到哪里无法确定，但是结果肯定大于等于3.

### 7.第七题

有以下程序

```c
#include <stdio.h>
#include <string.h>
void fun(char *s) {
    char a[10];
    strcpy(a, "STRING");
    s = a;
}
 
main() {
    char *p = "PROGRAM";
    fun(p);
    printf("%s\n", p);
}
```

程序运行后的输出结果是(此处□代表空格)?

A

STRING

B

STRING□□□□

C

STRING□□□

D

PROGRAM

解答：

本题考查字符串指针作为函数参数,本题中p作为字符串指针传入fun中,p指向的内容并没有发生变化,所以选项D正确。

### 8.第八题

以下程序的输出结果为（）。

```c
#include<stdio.h>
#define ADD(x)  x*x
 
main( )
 
{  int a=4,b=6,c=7,d=ADD(a+b)*c;
 
printf("d=%d",d);
 
}
```

A

d=70

B

d=80

C

d=140

D

d=700

解答：

宏展开

首先，宏定义 `#define ADD(x) x*x` 将被展开为 `x * x`。因此，当我们用 `ADD(a+b)` 替换时，会得到 `a+b * a+b`。这里需要注意 C 中宏替换不考虑运算优先级，所以 `a+b * a+b` 会先计算 `b * a+b`。

替换宏后的表达式

现在我们替换宏 `ADD(a+b)`：

```c
d = a + b * a + b * c;
```

计算表达式

现在我们计算 `d` 的值：

```c
d = a + b * a + b * c;
d = 4 + 6 * 4 + 6 * 7;
d = 4 + 24 + 42;
d = 70;
```

输出结果

最后，将 `d` 的值打印出来：

```c
printf("d=%d", d);
```

结论

因此，程序运行后的输出结果是：

A. d=70

因为 `d` 被计算为 `70`，所以正确答案是 A。

### 9.第九题

以下程序的运行结果是（）

```c
#include <stdio.h>
int main(void) {
    printf("%s , %5.3s\n", "computer", "computer");
    return 0;
}
```

A

computer , puter

B

computer , com

C

computer , computer

D

computer , compu.ter

解答：

`printf` 格式说明符解析

- `%s`：用于输出一个以 null 结尾的字符串。
- `%5.3s`：表示输出一个最少宽度为5个字符，且仅输出字符串的前3个字符。

参数解析

1. `"computer"`：这是第一个参数，直接被 `%s` 格式说明符使用，输出整个字符串 `"computer"`。
2. `"computer"`：这是第二个参数，被 `%5.3s` 格式说明符使用，输出字符串的前3个字符，填充到最少宽度为5个字符。

计算输出结果

对于 `%s`：

- `"computer"` 输出为 `computer`。

对于 `%5.3s`：

- `"computer"` 输出为 `com`，因为只输出了前3个字符，并且填充到5个字符的宽度。

组合输出结果

所以，程序运行后的输出结果是：

B. computer , com

因为第一个 `%s` 输出整个字符串 `"computer"`，第二个 `%5.3s` 输出字符串的前3个字符，填充到5个字符的宽度。

## 第三天

### 第一题

有以下程序

```c
int main() {
  int a[]={1,2,3,4,5,6,7,8,9,0}, *p;
  for(p=a; p < a+10; p++)
    printf("%d,",*p);
}
```

程序运行后的输出结果是（）

A

1，2，3，4，5，6，7，8，9，0，

B

2，3，4，5，6，7，8，9，10，1，

C

0，1，2，3，4，5，6，7，8，9，

D

1，1，1，1，1，1，1，1，1，，1，

解答：

程序分析

1. **数组初始化**：

   ```c
   int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
   ```

   这段代码定义了一个包含10个整数的数组 `a`。

2. **指针初始化**：

   ```c
   int *p;
   ```

   这里定义了一个指向整数的指针 `p`。

3. **循环遍历数组**：

   ```c
   for (p = a; p < a + 10; p++)
       printf("%d,", *p);
   ```

   - `p = a;` 将指针 `p` 初始化为指向数组 `a` 的第一个元素。
   - `p < a + 10;` 判断条件为 `p` 是否小于数组 `a` 的第10个元素的地址（`a + 10`）。
   - `p++` 在每次循环结束后将指针 `p` 移动到下一个数组元素。
   - `printf("%d,", *p);` 打印当前指针 `p` 所指向的数组元素的值，并在其后加上一个逗号。

输出结果

这个循环从数组 `a` 的第一个元素开始，一直遍历到第10个元素。每次循环中，打印当前指针 `p` 所指向的元素值，并在其后加上一个逗号。因此，数组中的每个元素都会被打印出来，并在其后跟一个逗号。

数组 `a` 中的元素依次是：`1, 2, 3, 4, 5, 6, 7, 8, 9, 0`。

因此，程序运行后的输出结果是：

A. 1，2，3，4，5，6，7，8，9，0，

正确答案是：

A. 1, 2, 3, 4, 5, 6, 7, 8, 9, 0,

### 第二题

有以下说明语句：

```c
struct Worker {
  int  no;
  char name[20];
};
Worker w, *p=&w;
```

则下列错误的引用是（）

A

w.no

B

p->no

C

(*p).no

D

*p.no

解答：

解析每个选项

A. `w.no`

`w` 是 `struct Worker` 类型的变量，使用点操作符（`.`）可以直接访问其成员 `no`。这是正确的。

```c
w.no
```

B. `p->no`

`p` 是指向 `struct Worker` 类型的指针，使用箭头操作符（`->`）可以访问指针指向的结构体的成员 `no`。这是正确的。

```c
p->no
```

C. `(*p).no`

`*p` 解引用指针 `p`，得到 `struct Worker` 类型的变量，使用点操作符（`.`）可以访问其成员 `no`。这是正确的。

```c
(*p).no
```

D. `*p.no`

这是错误的，因为点操作符（`.`）的优先级高于解引用操作符（`*`）。`p.no` 表示 `p` 是 `struct Worker` 类型的变量，但实际上 `p` 是一个指向 `struct Worker` 类型的指针。因此，这个表达式试图解引用 `p` 的成员 `no`，但这在语法上是错误的。

正确的方式是使用箭头操作符或先解引用指针：

```c
(*p).no   // 或者
p->no
```

结论

下列错误的引用是：

D. `*p.no`

知识点：操作符的优先级

### 优先级从高到低

1. **括号和成员选择**
   - `()`、`[]`、`->`、`.` （从左到右）
2. **单目操作符**
   - `!`、`~`、`-`（负号）、`++`（前置）、`--`（前置）、`(type)`（类型转换）、`*`（解引用）、`&`（取地址）、`sizeof`、`_Alignof` （从右到左）
3. **乘法和除法**
   - `*`、`/`、`%` （从左到右）
4. **加法和减法**
   - `+`、`-` （从左到右）
5. **位移操作符**
   - `<<`、`>>` （从左到右）
6. **关系操作符**
   - `<`、`<=`、`>`、`>=` （从左到右）
7. **相等性操作符**
   - `==`、`!=` （从左到右）
8. **按位与**
   - `&` （从左到右）
9. **按位异或**
   - `^` （从左到右）
10. **按位或**
    - `|` （从左到右）
11. **逻辑与**
    - `&&` （从左到右）
12. **逻辑或**
    - `||` （从左到右）
13. **条件操作符**
    - `? :` （从右到左）
14. **赋值操作符**
    - `=`、`+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`&=`、`^=`、`|=` （从右到左）
15. **逗号操作符**
    - `,` （从左到右）

### 第三题

设char型变量x中的值为10100111，则表达式(2 + x)^(~3)的值是（ ）

A

10101001

B

10101000

C

11111101

D

01010101

解答：

1. 将 `x` 转换为十进制

`x` 的二进制值为 `10100111`。

将二进制转换为十进制：

```c
1*2^7 + 0*2^6 + 1*2^5 + 0*2^4 + 0*2^3 + 1*2^2 + 1*2^1 + 1*2^0
= 128 + 0 + 32 + 0 + 0 + 4 + 2 + 1
= 167
```

所以，`x` 的十进制值为 `167`。

2. 计算 `2 + x`

```c
2 + 167 = 169
```

`169` 的二进制表示为 `10101001`。

3. 计算 `~3`

在C语言中，按位取反操作符 `~` 将一个数的每一位取反。

`3` 的二进制表示为 `00000011`。

将 `00000011` 取反：

```c
~00000011 = 11111100
```

4. 计算 `(2 + x)^(~3)`

现在我们有：

```c
(2 + x) = 10101001
(~3) = 11111100
```

我们需要计算二者的按位异或（XOR）操作 `^`：

```c
  10101001
^ 11111100
-----------
  01010101
```

所以，`(2 + x)^(~3)` 的二进制结果是 `01010101`。

结论

表达式 `(2 + x)^(~3)` 的值是 `01010101`。

正确答案是：

D. 01010101

知识点：

按位异或（XOR）运算是一种二进制操作，它对两个操作数的每一位进行比较。当且仅当两个对应的二进制位不同时，结果位为1，否则结果位为0。具体来说，对于每一位上的计算规则如下：

- 0 ^ 0 = 0
- 0 ^ 1 = 1
- 1 ^ 0 = 1
- 1 ^ 1 = 0

## 第四天

### 第一题

```c
char* getmemory(void){
  char p[]= " hello world";
  return p;
}
void test(void){
  char *str=NULL;
  str=getmemory(); printf(str);
}
```

请问运行Test 函数会有什么样的结果？

A

出错

B

输出"hello world"

C

输出空""

D

输出乱码

解释： getmemory 返回的指针，是内部变量， 调用之后会被回收。 所以输出是不确定的。答案为D

在 `getmemory` 函数中，`p` 是一个局部数组变量，它在函数结束时自动销毁。因此，返回的指针 `char *` 将指向一个已经无效的内存地址。这种情况下，访问这个指针所指向的内容将导致未定义行为，通常表现为输出乱码或者程序崩溃。

### 第二题

假定所有变量均已正确定义，下列程序段运行后 x 的值是（）

```c
k1=1;
k2=2;
k3=3;
x=15;
if(!k1) x--;
else if(k2) x=4;
else x=3;
```

A

14

B

4

C

15

D

3

解释：`if (!k1)`：`!k1` 表达式求值为 `0`，因为 `k1` 的值为 `1`，非零值在逻辑上被视为真。因此，这个条件不成立，不执行其内部的语句块。

`else if (k2)`：`k2` 的值为 `2`，非零值在逻辑上被视为真。因此，这个条件成立，执行其内部的语句块。

### 第三题

32位环境下,给定结构体

```c
Struct A{
  Char t : 4;
  Char k : 4;
  Unsigned short i : 8;
  Unsigned long m;
};
```

问 sizeof （ A ） =_____;

A

7

B

6

C

8

D

上述答案都不对

解释：

```c
struct Chat {
    char t : 4;
};
```

这个结构体 `Chat` 中的成员 `t` 是一个4位的字符型位域。这意味着 `t` 可以存储的范围是从 `0000` 到 `1111`，即十进制的 `0` 到 `15`。在内存中，系统会尽量将多个位域打包在一个字节中，以节省空间。

**位域的位宽不能超过其数据类型的大小**。例如，一个 `char` 类型的位域最多只能有8位。

**位域在内存中的布局受到具体编译器的实现影响**。不同的编译器可能会以不同的方式对位域进行排列。

**位域的使用通常局限于对硬件寄存器进行位操作或者在内存空间受限的嵌入式系统中**。在一般的应用程序中，使用位域时需要谨慎考虑其可移植性和代码的可读性。

### 第四题

下列程序段的功能是判断字符串是否对称，对称返回1，不对称返回0，请将缺失处处缺失程序补充完整。

```c
bool fun(string str) {
  int i=0,j=0;
  j = ____;
  for (j--; i < j && str[i]==str[j]; i++, j--);
  return i <= j;
}
```

A

i+1

B

i

C

strlen(str)

D

str.size()

解释：`str.size()` 是 C++ 标准库中 `std::string` 类的方法，用于返回字符串 `str` 的大小，即字符的个数。

在函数中，`j = str.size();` 将 `j` 初始化为字符串 `str` 的长度。

在循环中，`for (j--; i < j && str[i] == str[j]; i++, j--);` 用于比较字符串的前半部分和后半部分，直到不对称或者相遇。

### 第五题

已知数组D的定义是int D[4][8];现在需要把这个数组作为实参传递给一个函数进行处理。下列可以作为对应的形参变量说明的是（）。

A

`int D[4][]`

B

`int *s[8]`

C

`int(*s)[8]`

D

`int D[][8]`

解答：

二维数组在内存中也是连续存储的，他可以通过 `arr[i][j]`寻址是因为我们定义了这个数组有多少列， 加入有N列，这样数组寻址的时候编译器会自动得到 *(arr+(j*N)+i)所以传参数的时候列数必须指定。 所以D正确A不正确。B表示有8个指向int指针的数组，不对，而C中(*s)等价于s[]。因此答案CD；

### 第六题

在下列流类中，可以用于处理文件的是（）

A

ios

B

iostream

C

strstream

D

fstream

解答：

A 选项 ios 是所有流类的基类，它派生出 istream 和 ostream
B 选项 iostream 继承自 istream 和 ostream 类，因为该类的功能兼两者于一身，既能用于输入，也能用于输出
C 选项 strstream 类同时可以支持 C 风格的串流的输入输出操作

D 选项 兼 ifstream 和 ofstream 类功能于一身，既能读取文件中的数据，又能向文件中写入数据

### 第七题

若有定义：

`char s[3][4]`;

则下列对数组元素s[i][j]的各种引用形式中，正确的是（）

A

`*(s+i)[j]`

B

`*(&s[0][0]+4 * i+j)`

C

`*((s+i)+j)`

D

`*(*(s+i)[j])`

解释：

选项 A: `*(s+i)[j]`

```c
*(s+i)[j]
```

- `s` 是一个数组名，`s+i` 表示第 `i` 行的指针，因此 `*(s+i)` 等效于 `s[i]`，表示第 `i` 行的首地址。
- `*(s+i)[j]` 尝试访问第 `i` 行的第 `j` 个元素，但语法上有问题，因为 `*(s+i)` 是一个指向数组的指针，不能直接用 `[j]` 索引操作。这种写法是错误的。

选项 B: `*(&s[0][0]+4 * i+j)`

```c
*(&s[0][0] + 4 * i + j)
```

- `&s[0][0]` 是数组 `s` 的第一个元素的地址，即整个二维数组的起始地址。
- `4 * i + j` 是计算从起始地址开始的偏移量，以访问 `s[i][j]` 元素。
- `*(&s[0][0] + 4 * i + j)` 表示通过计算的地址偏移来访问 `s[i][j]` 元素，是正确的写法。

选项 C: `*((s+i)+j)`

```c
*((s+i)+j)
```

- `s+i` 是指向二维数组 `s` 的第 `i` 行的指针，即 `&s[i][0]`。
- `*((s+i)+j)` 尝试访问第 `i` 行的第 `j` 列的元素，语法上是正确的，表示 `s[i][j]` 元素的值。

选项 D: `*(*(s+i)[j])`

```c
*(*(s+i)[j])
```

- `s[i]` 表示第 `i` 行的数组元素，因此 `s[i][j]` 是第 `i` 行第 `j` 列的元素。
- `*(s+i)[j]` 尝试对 `s[i]` 的第 `j` 个元素进行解引用，然后再次解引用，这样会导致语法错误，因为 `s[i][j]` 是一个 `char` 值，不是指针。

结论：

正确的引用形式来访问数组元素 `s[i][j]` 是 **选项 B**：`*(&s[0][0] + 4 * i + j)`。

### 第八题

假设在上下文和头文件正常的情况以下，下面程序的结果是什么（）

```c
char* f(char *str, char ch) {
  char *it1 = str;
  char *it2 = str;
  while (*it2 != '\0') {
    while (*it2 == ch) { it2++; }
    *it1++ = *it2++;
   }
  return str;
}
int main(int argc, char *argv[]) {
  char *a = new char[10];
  strcpy(a, "abcdcccd");
  cout << f(a, 'c');
}
```

A

abdcccd

B

abdd

C

abcc

D

abddcccd

E

Access Violation

解释：

函数 f 中，it1 和 it2 都指向数组，其内容为 "abcdcccd"，ch 为 'c'；函数中外循环的结束条件为 it2 指向 '\0'，内循环的结束条件为 it2 不指向字符 'c'；it2 一开始指向 'a'，所以第一次内循环不执行，执行 *it1++ = *it2++; 将 it1 指向的字符替换成 it2 指向的字符 'a'，然后分别自增；it1 和 it2 指向 'b'，同上一步操作；it1 和 it2 指向 'c'，此时内循环执行，it2++，it2 指向 'd'，内循环结束，执行 *it1++ = *it2++; it1 执行的字符替换成 'd'，然后分别自增；it1 指向索引为 3 的 'd'，it2 指向索引为 4 的 'c'，此时内循环执行，it2++，it2 指向后一个 'c'，一直到 it2 指向最后 'd'，此时执行 *it1++ = *it2++; it1 指向索引为 3 的字符变成 'd'，然后分别自增，it2 执行 '\0'，整个外循环结束。最终结果为 abddcccd。

## 第五天

### 第一题

下列定义不正确的是（ ）

A

\#define PI 3.141592

B

\#define S345

C

int max(x,y); int x,y; { }

D

static char c;

解释：

\#define S345 是空宏定义    一般空的宏定义的作用是    1. 对函数进行标识、说明    2. 可以解决编译器兼容的问题，eg：#difine typename //有的编译器会不兼容给typename ...收起 

  \#define S345 是空宏定义 

  一般空的宏定义的作用是 

1. 对函数进行标识、说明 

2. 可以解决编译器兼容的问题，eg：#difine typename //有的编译器会不兼容给typename 

### 第二题

```c
char* s="AAA"; //1
printf("%s",s); //2
s[0]='B'; //3
printf("%s",s); //4
```

解答：初始化指针时所创建的字符串常量被定义为只读。如果试图通过指针修改这个字符串的值，程序就会出现未定义的行为。S[0]只可读，不可写 

### 第三题

printf函数中用到格式符%5s，其中数字5表示输出的字符串占用5列，如果字符串长度大于5，则输出按方式（ ）

A

从左起输出该字符串,右补空格

B

按原字符长从左向右全部输出

C

右对齐输出该字串,左补空格

D

输出错误信息

解答：分情况看待： 

1：字符串长度比设定长度大就按字符串实际长度输出； 

2：字符串长度比设定长度小就按右对齐输出该字串,左补空格。 

3：如果数字之前有-，即%-5s表示左对齐输出

### 第四题

若有代码段

```c
int *p = (int*)malloc(sizeof(int));
```

则向内存申请到的内存空间中存入整数123的语句为（ ）

A

scanf("%d", p);

B

scanf("%d", &p);

C

scanf("%d", *p);

D

scanf("%d", **p);

解答：

p 是 int 的指针类型，scanf 要求 %d 相应参数也是 int 的指针类型，所以直接  `scanf("%d",p);`   即可。    
B 项， &p 又取了一次 p 的地址，相当于指针的指针， scanf 尝试写入原本是指针的地址，导致 p 的值被改变（本应写入 p 指向的内存），后续解引用 *p 可能导致访问非法内存 产生运行时读内存错误。    C 项， *p 解引用取值，是一个未初始化的乱值， scanf 会把该值当作地址，可能导致运行时写内存错误或写入不被期望的内存区域。    D 项， p 只是一次指针， **p 会编译错误。 ...收起 

p 是 int 的指针类型，scanf 要求 %d 相应参数也是 int 的指针类型，所以直接 

```cpp
scanf("%d",p);
```

即可。 

B 项， &p 又取了一次 p 的地址，相当于指针的指针， scanf 尝试写入原本是指针的地址，导致 p 的值被改变（本应写入 p 指向的内存），后续解引用 *p 可能导致访问非法内存 产生运行时读内存错误。 

C 项， *p 解引用取值，是一个未初始化的乱值， scanf 会把该值当作地址，可能导致运行时写内存错误或写入不被期望的内存区域。 

D 项， p 只是一次指针， **p 会编译错误。 

### 第五题

假定x=500，下面函数的返回值是 （）

```c
int fun(int x){
  int countx = 0;
  while (x) {
    countx++;
    x = x & (x – 1);
  }
  return countx;
｝
```

A

2

B

3

C

5

D

6

解答：

二进制数每减1都会使最低位的1及之后的位都取反，这样再与原来的自身相与则最低位及之后的位都会变成0.这样从右往左消1，每循环一次消一个1，所以说这个算法是用来数1的。

### 第六题

下面指针所指向的内存，可以修改的是（）

A

const int* a

B

int const* b

C

int* const c

D

const int* const d

解答：

const默认修饰左边的内容，如果左边没有东西则修饰其右边的内容 

const int *a  const左边没有东西，因此const修饰int，则指针指向的内容不可通过指针修改 

int const *a  const左边有东西，因此const修饰int 

int* const a  const修饰*，即指针不能改变指向 

const int * const a 第一个const修饰int，第二个const修饰*，即指针指向内容不可修改，也不能改变指针指向 

总结：*在const左边，不能改变指针指向，*在const右边，不能修改所指的值 

### 第七题

在x86系统下,sizeof如下结构体的值是多少?

```c
struct{ 
char a[10];
int b;
short c[3];
}
```

A

20

B

22

C

24

D

26

相对简单的内存对齐,需要注意的是char a[10];并不是代表结构体需要对齐最长的长度是10,它只是10个char聚在一起,本质没有变化 所以说,需要对齐的最大长度还是4,故4(char a[4])+4(char a[4]) +4(char a[2] 由于内存对齐为4)+4(int)+4(short[2])+4(short[1]内存对齐为4)=6*4=24

### 第八题

```c
class A;
class B;
int main() {
  A a; 
  B b; 
  return 0;
}
```

在 main 函数中，变量 a 和 b 的构造函数和析构函数的调用顺序是（）

A

b构造 - a构造 - a析构 - b析构

B

a构造 - a析构 - b构造 - b析构

C

b构造 - a构造 - b析构 - a析构

D

a构造 - b构造 - b析构 - a析构

解答：

创建对象时会调用构造函数对对象进行初始化，对象销毁时会调用析构函数释放一些资源。
这里 a 对象和 b 对象都是局部变量，位于栈上。且 a 先于 b 创建，所以先执行 a 的构造函数，然后执行 b 的构造函数。
当 main 函数执行完以后，b 对象先出栈，所以先调用 b 的析构函数，然后 a 对象出栈，调用 a 的析构函数。

### 第九题

`scanf("a=%d,b=%d", &a, &b);`如果要输出a=1,b=1,那么应该输入什么

解答：为了使用 `scanf` 函数正确地解析输入字符串并将数值赋给变量 `a` 和 `b`，你需要确保输入的格式严格匹配 `scanf` 函数中定义的格式字符串。具体来说，输入字符串必须包含格式字符串中的所有字符和空格。

***详细说明***

- **格式字符串匹配**：`scanf("a=%d,b=%d", &a, &b);` 要求输入字符串必须完全匹配 `"a=%d,b=%d"` 这个格式字符串，除了 `%d` 位置可以是任意整数，其他字符（包括 `a=`, `,` 和 `b=`）必须逐字符匹配。
- **输入内容**：在输入时，你需要输入一个与格式字符串完全匹配的字符串。对于 `scanf("a=%d,b=%d", &a, &b);`，正确的输入示例是 `a=1,b=1`。
- **格式说明符 `%d`**：`%d` 是一个格式说明符，用于读取整数。`scanf` 函数会将读取的整数分别赋值给变量 `a` 和 `b`。

## 第六天

### 第一题

对于int *target[5]的描述，以下选项是正确的是（）

A

target是一个具有5个元素的指针数组，每个元素是一个int类型的指针

B

target[5]表示某个数组的第5个元素的值

C

target是一个指向数组的指针，所指向的数组是5个int类型的元素

D

target是一个指向某个数组中第5个元素的指针，该元素是int类型的变量。

解答：

int *target[n]是指针数组，[]优先级高，先与target结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。int (*target)[n]是数组指针，()优先级高，首先说明target是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是target的步长。

### 第二题

```c
class A {
  int a;
  short b;
  int c;
  char d;
};
class B {
  double a;
  short b;
  int c;
  char d;
};
```

在32位机器上用gcc编译以上代码，求sizeof(A)，sizeof(B)分别是（）

A

12 16

B

12 12

C

16 24

D

16 20

解答：

1. 结构体变量的首地址 必须 是内部最宽数据类型的倍数（虽然和做题没什么关系） 

2. 按顺序一个变量一个变量看，要求current变量的首地址 必须是自己大小的倍数。 

3. 到了最后一个变量，要求整个结构体的大小的最宽数据类型的倍数。 

A: int a    （4个字节）                         4 

  short b   (2个字节，起始地址4是2的倍数，不补)    4+2


  int c     (4个字节，4+2不是4的倍数，被2个 )    4+2+2（补）+4


  char d    (1个字节，4+2+2+4是1的倍数，不补)  4+2+2（补）+4 +1


  最后补3个字节，让整体大小为4的倍数   4+2+2(补)+4+1+3（补） =16 

   B: double a    （8个字节）                         8  

   short b   (2个字节，起始地址8是2的倍数，不补)    8+2


   int c     (4个字节，8+2不是4的倍数，被2个 )    8+2+2（补）+4


   char d    (1个字节，8+2+2+4是1的倍数，不补)  8+2+2（补）+4 +1


   最后补7个字节，让整体大小为8的倍数   8+2+2(补)+4+1+7（补） =24  

### 第三题

下面选项中关于 " 文件指针 " 概念的叙述正确的是（）

A

文件指针是 FILE 指针类型的变量

B

文件指针就是文件位置指针，表示当前读写数据的位置

C

文件指针指向文件在计算机中的存储位置

D

把文件指针传给 fscanf 函数，就可以向文本文件中写入任意的字符

解答：

在 C 语言中用一个指针变量指向一个文件，这个指针称为文件指针。通过文件指针就可对它所指的文件进行各种操作。文件指针不是文件位置指针，所以 BC 选项错误， D 选项中不可以写入任意的字符。

### 第四题

以下选项中，对基本类型相同的指针变量不能进行运算的运算符是（）

A

+

B

\-

C

=

D

==

解答：

A错误，因为两个地址相加无意义也可能越界，所以规定不允许指针相加。 其他的都很好理解，B选项，可以求出两个数据元素储存位置之间的相隔同数据类型的元素个数，C选项，赋值，很好理解，D选项，判断两指针所指向的是否是同一数据元素

## 第七天

### 第一题

在C语言中，以下代码执行之后，*p的值为（）

```c
void func(int *p){
  static int num = 4;
  p = #num;
  (*p)--;
}
int main(){
  int i = 5;
  int *p = &i;
  func(p);
  printf("%d", *p);
  return 0;
}
```

A

3

B

4

C

5

D

以上都不是

解答：

首先，main函数内:p指向i的地址。在fun函数传递的是p的值，p的值就是i的地址，因此传递的是i的地址。 其次，在fun函数内，形参p接收i的地址，此时形参p也指向i(同main函数内的实参p一样，此时有两个指针指向i)。之后，形参p指向静态变量num，这样形参修改的话修改的是num的值。而i只有main函数内的实参p指向，fun函数的p已经不指向i了。 因此，实参p没有改变，i也没有改变。

### 第二题

字符常量的长度肯定为1

正确

解答：

字符常量是用单引号括起来的单个字符，例如`'A'`、`'b'`、`'1'`。它们表示一个单一的字符，并且在内存中占用1个字节的空间。字符常量的类型是 `int`，而不是 `char`，这是因为在C语言中字符常量被提升为 `int` 类型。

## 第八天

### 第一题

对于下面代码段

```c++
char *const name = new char[5]；
```

解释：

A 说明：name被定义常指针，所以它所指的内容能改变，但指针本身的内容不可以修改，nameC3J='q'；"修改了name所指的内容，是正确的。而"name="lin"；' name= new Char

[5]；"和"name-new char（'q'）；"以不同的方法修改了常指针，都是错误的。

### 第二题

switch()中不允许的数据类型有?

A

整型

B

浮点型

C

字符串

D

布尔

解释：

1. char、short、int、long、bool 基本类型都可以用于switch语句。 
2. float、double都不能用于switch语句。
3. enum类型，即枚举类型可以用于switch语句。 
4. 所有类型的对象都不能用于switch语句。 
5. 字符串也不能用于switch语句

### 第三题

下列语句中错误的是（）

A

int *p = new int(10);

B

int *p = new int[10];

C

int *p = new int;

D

int *p = `new int[40](0)`;

解答：

说明："int * p=new int（10）；"表示动态分配1个整型内存空间，初值为10；

"int * p=new int[10]；"表示动态分配10个整型内存空间；

'int * p=new int；"表示动态分配1个整型内存空间；

"int * p=new int [40]（0）"想给一个数组分配内存空间时，对数组进行初始化，这是不允许的。

### 第四题

```c++
int Function(unsigned int n) { 
    n = (n & 0x55555555) + ((n >> 1) & 0x55555555);
    n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
    n = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);
    n = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);
    n = (n & 0x0000ffff) + ((n >> 16) & 0x0000ffff);
    return n;
}
```

输入参数为197时，函数返回多少？

A

2

B

3

C

4

D

5

解答：

计算二进制的一的个数，这个算法叫做平行算法。  

​    int BitCount(unsigned int n)   

​    {   

​      n = (n &0x55555555) + ((n >>1)      &0x55555555) ;   

​      n = (n &0x33333333) + ((n >>2)      &0x33333333) ;   

​      n = (n &0x0f0f0f0f) + ((n >>4)      &0x0f0f0f0f) ;   

​      n = (n &0x00ff00ff) + ((n >>8)      &0x00ff00ff) ;   

​      n = (n &0x0000ffff) + ((n >>16)      &0x0000ffff) ;   

​      return n ;   

​    }   

​    速度不一定最快，但是想法绝对巧妙。      说一下其中奥妙，其实很简单，先将n写成二进制形式，然后相邻位相加，重复这个过程，直到只剩下一位。   

​      

​    以217（11011001）为例，有图有真相，下面的图足以说明一切了。217的二进制表示中有5个1   

  ![img](http://uploadfiles.nowcoder.com/images/20160126/932073_1453819993073_ACED241801E307EE7A39612F85A94EBF)

### 第五题

若有定义int a[8];，则以下表达式中不能代表数组元素a[1]的地址的是（）

A

&a[0]+1

B

&a[1]

C

&a[0]++

D

a+1

解答：

选项 A: `&a[0] + 1`

`&a[0]` 是数组第一个元素的地址，加 1 后就是下一个元素的地址，即 `&a[1]`。所以这个表达式是正确的，可以代表 `a[1]` 的地址。

选项 B: `&a[1]`

`&a[1]` 是数组第二个元素的地址，直接就是 `a[1]` 的地址。所以这个表达式是正确的。

选项 C: `&a[0]++`

`&a[0]++` 这个表达式实际上是非法的，因为 `&a[0]` 是一个指针常量，不能对其进行递增操作。这个表达式会产生编译错误。所以这个表达式不能代表 `a[1]` 的地址。

选项 D: `a + 1`

`a` 是数组的首地址，即 `&a[0]`，加 1 后就是下一个元素的地址，即 `&a[1]`。所以这个表达式是正确的，可以代表 `a[1]` 的地址。

`[]` (数组下标) 的优先级高于 `&` (取地址) 和 `++` (后置自增)。

`&` (取地址) 的优先级高于 `++` (后置自增)。

### 第六题

请阅读下面代码片段并且回答问题：

```c
#define SIZE_20M (20*1024*1024)
void func_a()
{
  char *temp = malloc(SIZE_20M)
  return;
}
void func_b()
{
  char temp[SIZE_20M];
  //...do something using temp
  return;
}
```

关于这段代码，下列说法正确的是

A

func_a 获得临时内存的方式效率通常更高。

B

func_b 使用了太多的栈，程序可能会在运行时候崩溃。

C

func_b 存在内存泄露

D

func_a 和func_b 分配的内存会自动初始化0

解答：

A  func_a()动态分配的数据位于堆区，func_b()的temp位于栈区，栈区的执行效率高于堆区，故func_b()效率高 C  func_b()中没有动态分配的内存，不存在泄露问题 D  都不会自动初始化为0，只有全局变量或者static变量会初始化为0 B  栈的空间一般为2M，分配太多栈空间程序肯定会崩溃

## 第九天

### 第一题

C语言中，若有定义: int a=8,b=5,c; ,执行语句c=a/b+0.4;后，c的值是（）

A

1.4

B

1

C

2.0

D

2

解答：

在C语言中，隐式类型转换确实会发生，但要了解具体的运作机制。我们再详细分析一下这个过程：

给定定义：`int a=8, b=5, c;`

执行语句：`c = a / b + 0.4;`

1. **整数除法**：
   - `a / b` 是整型除法，因此 `8 / 5` 的结果是 `1`（小数部分被舍弃）。
2. **隐式类型转换**：
   - 在执行 `a / b + 0.4` 时，`1` 是整型数，`0.4` 是浮点数。根据C语言的隐式类型转换规则，`1` 会被转换为浮点数 `1.0`，然后进行浮点数加法。
3. **浮点数加法**：
   - `1.0 + 0.4` 的结果是 `1.4`，这是一个浮点数。
4. **赋值操作**：
   - 将浮点数 `1.4` 赋值给整型变量 `c` 时，会进行截断操作，`1.4` 被截断为 `1`。

因此，尽管在计算过程中发生了隐式类型转换，但最终赋值给整型变量 `c` 时，浮点数 `1.4` 被截断为 `1`。

所以，`c` 的值仍然是 `1`。

### 第二题

三个用户在同一系统中使用同一个编译程序同时对他们的 C 语言源程序进行编译，此时系统应分别为各用户创建一个 C
编译进程并各保留一份 C 编译程序副本，这样的说法正确吗？

A

正确

B

不正确

解答：

错误。如果三个用户运行同一个程序（编译程序），则系统将创建3 个进程，但这3 个进程共享C 编译程序的1 个副本，而不是3 个副本。  

### 第三题

const char *p 说明了 p 是指向字符串的常量指针。

A

正确

B

错误

解答：

`p` 是一个指向字符常量的指针，而不是指向字符串的常量指针。

## 第十天

### 第一题

以下代码在64位的机子上输出是（）

```c
#include <stdio.h>
int getSize(int data[]){
  return sizeof(data);
}
int main(){
  int data1[] = {1,2,3,4,5};
  int size1 = sizeof(data1);
  
  int* data2 = data1;
  int size2 = sizeof(data2);
  
  int size3 = getSize(data1);
  
  printf("%d, %d, %d", size1, size2, size3);
  return 0;
}
```

 A

20,8, 8

B

4, 4, 4

C

20, 4, 20

D

20, 20, 20

解答：

64位的机子 指针8位  

32位的机子 指针4位 

指针的位数只和机子的位数有关和数的类型无关。 

数组名在函数中会退化为指针。 



### 第二题

若有以下程序段：

```c
int a[] = {4, 0, 2, 3, 1}, i, j, t;
for(i = 1;i < 5;i++) {
  t = a[i];
  j = i - 1;
  while(j >= 0 && t > a[j]){
    a[j + 1] = a[j];
    --j;
  }
  a[j + 1] = t;
}
```

则该程序段的功能是：

A

对数组a进行插入排序（升序）

B

对数组a进行插入排序（降序）

C

对数组a进行选择排序（升序）

D

对数组a进行选择排序（降序）

解答：

插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序排列之中，其特点是要不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去。
选择排序的原理：每次在无序队列中“选择”出最小值，放到有序队列的最后，并从无序队列中去除该值（具体实现略有区别）。
在第 i 次排序中，前 i - 1 个元素始终是有序的，此时只需把第i个元素插入到有序的序列中即可，故代码中体现的是插入排序的思想。代码中对当前 a[i]>a[j]（0<=k<i-1）是否成立进行判断，若成立则将 a[j] 往后移（即大的数排在前面，小的数排在后面），故代码中的排序原则为降序排。

### 第三题

以下代码的输出结果是?

```c
#include <stdio.h>
#define a 10
void foo(); 
int main(){ 
  printf("%d..", a); 
  foo(); 
  printf("%d", a); 
} 
void foo(){ 
  #undef a 
  #define a 50 
}
```

A

10..10

B

10..50

C

Error

D

0

解答：

选A，define在预处理阶段就把main中的a全部替换为10了. 另外，不管是在某个函数内，还是在函数外，define都是从定义开始知道文件结尾，所以如果把foo函数放到main上面的话，则结果会是50  ，50 

从第一行到第10行，a为10；从第12行开始，a为50。与逻辑没有关系，预处理按照从上到下

### 第四题

存在int类型变量x，y，z，其对应值为x=0x59，y=0x39，z=0x6E，则x*y+z的值为（）

A

‘1001001110011

B

‘1010000111111

C

‘1001001110111

D

‘1011001111111

解答：

十六进制0x59->十进制5*16+9=89;  十六进制0x39->十进制3*16+9=57;  十六进制0x6E->十进制6*16+14=110;   十进制89*57+110=5183->二进制1010000111111 

### 第五题

有以下程序

```c
main() {
  char *a = "How are you?", b[20];
  ______________________________
  printf("%s %s\n",a,b);
}
```

请为横线处选择适当的输入语句使得（ ）
程序运行时从键盘输入：How are you?<回车>
得到的输出结果为How are you? How

A

gets(b);

B

scanf("%s", b);

C

b=getchar();

D

while(b=getchar()!="\0");

解答：

gets是得到一整行的字符串; 

getchar是得到一个字符； 

scanf("%s")是得到一个连续的字符串，遇到空格、回车会自动终止 

### 第六题

```c
void main (void) {
  int x;
  x = printf("I See, Sea in C");
  printf("x=%d", x); 
}
```

程序完成后x的值是（）

A

2

B

随机值

C

都不是

D

15

解答：

int printf ( const char * format, ... );**返回值：** 
正确返回输出的字符总数，错误返回负值，与此同时，输入输出流错误标志将被置值，可由指示器ferror来检查输入输出流的错误标志。(注意'\0'不算)

### 第七题

代码段

```c
#include <stdio.h>
int main() {
  int i = 1;
  sizeof(i++);
  printf("%d\n", i);
  return 0;
}
```

 的输出为（）



A

1

B

4

C

2

D

8

解答：

根据C99规范， sizeof是一个编译时刻就起效果的运算符，在其内的任何运算都没有意义，
 sizeof(i++); 在编译的时候被翻译成 
 sizeof((i++的数据类型)) 也就是 sizeof(int); 不会执行i++了。

 sizeof是运算符,它在编译时起作用，而不是运行时。
 也就是说，在编译时，就得到了sizeof(int)，运行时，i++根本没有执行过

简而言之，sizeof括号里面的表达式是不参与运算的 

## 第十一天

### 第一题

下列关于const关键字的说法错误的是：

A

用const常量代替宏定义可以让编译器进行安全性检查

B

类的const成员函数不能修改类的成员变量，而且一个const类对象只能调用其const成员函数，不能调用非const成员函数

C

const成员函数与同名、同返回值、同参数列表的非const成员函数属于重载现象

D

推荐使用以下方面定义类成员数组： class A{ … const size_t SIZE=100; int _array[SIZE]; };

解答：



D选项是错误的 

const成员只能在构造函数的初始化列表中初始化 

如果非要在类中声明处初始化，就要加上static才行，而且初始化的对象必须是整型

### 第二题

下列main()函数执行后的结果为()

```c
int func(){ 
  int i, j, k = 0;
  for(i = 0, j =- 1;j = 0;i++, j++){
    k++;
  }
  return k;
}
int main(){
  cout << (func());
  return 0;
}
```

A

-1

B

0

C

1

D

2

解答：

 **for(a；b；c）**  
//1、 当执行到for循环时，a部分语句会且**只会执行一次** ，相当于进行一次初始化。

//2、b部分为 **循环判定条件** ，true则执行，在**执行循环体内之前**进行的条件判断。

// 3、C部分：执行一次循环后，再进行下一次条件判断也就是b部分的时候会执行c部分。  本题关键在考察**逗号表达式**以及**for循环执行条件**，仔细一点可以看清本质的。

### 第三题

以下#pragma预处理命令哪个是改变编译器的对齐方式（）

A

\#pragma comment

B

\#pragma pack

C

\#pragma data_seg

D

\#pragma once

解答：

 **#pragma comment**。将一个注释记录放置到对象文件或可执行文件中。 

**#pragma pack**。用来改变编译器的字节对齐方式。 

**#pragma code_seg**。它能够设置程序中的函数在obj文件中所在的代码段。如果未指定参数，函数将放置在默认代码段.text中

**#pragma once**。保证所在文件只会被包含一次，它是基于磁盘文件的，而#ifndef则是基于宏的。

### 第四题

下面哪些运算符不能被重载（）

A

三目运算符“?:”

B

作用域运算符“::”

C

对象成员运算符“.”

D

指针成员运算符“->”

解答：

不能被重载的运算符只有五个，分别是 

  \1.  .  （成员访问运算符） 

  \2.  *   （成员指针访问运算符） 

  \3.  ::  （域运算符） 

  \4.  sizeof  （长度运算符） 

  \5. ?:   （条件运算符） 

前两个运算符不能重载是为了保证访问成员的功能不被改变 ，域运算符和sizeof运算符的运算对象是类型而不是变量或者一般表达式，不具备重载的特征

### 第五题

开发C代码时,经常见到如下类型的结构体定义:

```c
typedef struct list_t{
struct list_t *next;
struct list_t *prev;
char data[0];
}list_t;
```



解答：

**选 B；**

  **柔性数组：**

把单一元素的数组放在一个struct的尾端，使得每个struct对象可以拥有可变大小的数组。 

开始题目中的**char data[0]** 或写成**char  data[]**，即为柔性数组； 

data**不占用struct的空间**，只是作为一个符号地址存在。  因此sizeof的值是两个指针所占字节，即4+4 = 8字节。

### 第六题

下列关于类中的静态成员的说法错误的是（）

A

虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针来访问静态成员

B

成员函数不用通过作用域运算符就能直接使用静态成员

C

静态数据成员不是由类的构造函数初始化的

D

静态成员不可以作为默认实参

解答：

类的所有成员共享一个静态成员。静态类数据成员必须在类的内部声明，在类的外部初始化。在访问静态成员时，可以通过对象访问，也可以通过类访问。通过this指针访问的数据成员和方法成员都必须是类的非静态成员。

### 第七题

在声明类时，下面的说法正确的是（）

A

可以在类的声明中给数据成员赋初值（c++11新标准）

B

数据成员的数据类型可以是register

C

private、public、protected可以按任意顺序出现

D

没有用private、public、protected定义的数据成员是公有成员

解答：

C++中没有限定private、public、protected的书写次序。但是，不能在类的声明中给数据成员赋初值，数据成员的数据类型也不能是register。没有用private、public、 protected定义的数据成员是私有成员

但是使用register修饰符有几点限制

 （1）register变量必须是能被CPU所接受的类型。

 这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。

 （2）因为register变量可能不存放在内存中，所以不能用“&”来获取register变量的地址。

 （3）只有局部自动变量和形式参数可以作为寄存器变量，其它（如全局变量）不行。

 在调用一个函数时占用一些寄存器以存放寄存器变量的值，函数调用结束后释放寄存器。此后，在调用另外一个函数时又可以利用这些寄存器来存放该函数的寄存器变量。

 （4）局部静态变量不能定义为寄存器变量。不能写成：register static int a, b, c;

 （5）由于寄存器的数量有限（不同的cpu寄存器数目不一），不能定义任意多个寄存器变量，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。

### 第八题

运行时的C程序，下列哪些变量在内存中的stack区域的有（）

```c
int a = 0;
char *p1;
int main(void) {
  int b;
  char s[] = "abc";
  char *p2;
  char *p3 = "123456";
  static int c =0；
  p1 = (char *)malloc(10);
  free(p1);
  return 0;
}
```

A

a

B

b

C

c

D

s

E

p1

解答：

 C语言在内存中一共分为如下几个区域，分别是：   

\1. 内存栈区： 存放局部变量名；
 \2. 内存堆区： 存放new或者malloc出来的对象；
 \3. 常数区： 存放局部变量或者全局变量的值；
 \4. 静态区： 用于存放全局变量或者静态变量；
 \5. 代码区：二进制代码。

## 第十二天

### 第一题

假设sizeof(void *)为4，sizeof(char)为1，那么对于char str[sizeof("ab")]，sizeof(str)的值是（）

A

2

B

3

C

4

D

代码无法编译

解答：

sizeof计算的是数据结构的大小，以字节计算。 str是数组的首地址，大小是4，和指针类型大小一样。但这并不意味着sizeof(str)的值为4。因为sizeof是计算数据结构的大小，数组就是一种数据结构，因此它计算的是整个数组的大小。 此外，对于" "，编译器都会自动在后面添一个/0，占据一个字节。

### 第二题

对于下面代码段，正确的赋值语句（ ）

```c
char a[5], *p=a;
```

A

p="abcd";

B

a="abcd";

C

*p="abcd";

D

*a="abcd";

解答：

a是一个字符数组，只能在声明的时候初始化，即char a[5]="abcd" 

  声明数组后再赋值是违法的，即a=“abcd”，因为数组是一个不可修改的左值 

  但是char *p=a ，p就是一个char *指针，是一个可修改的左值，所以可以将其指向新的字符串"abcd"

### 第三题

能把函数处理结果的二个数据返回给主调函数，在下面的方法中不正确的是（）

A

return这二个数

B

形参用数组

C

形参用二个指针

D

用二个全局变量

解答：

return只能返回一个符合返回类型的值，不能返回多个

### 第四题

C语言程序中的整数不能是（）。

A

二进制整数

B

八进制整数

C

十六进制整数

D

十进制整数

解答：

C 语言中有三种进制表示 

1. ​    八进制：以 0 开头， 数的每一位不能大于 7      
2. ​    十进制：普通的整数，都是十进制， 数的每一位不能大于 9      
3. ​    十六进制：以 0x,或 0X 开头，数的每一位不能大于F   

### 第五题

语句scanf("%7.2f", &a);是一个合法的scanf函数。请问这句话的说法是正确的吗？

A

正确

B

错误

解答：

scanf不能指定输入精度，可以指定长度。 

比如%m.nf是不允许的，但是可以%mf。m为整数。

## 第十三天

### 第一题

下面代码加入下面那个函数后返回TRUE:
return ? == 'A';

A

ord(65)

B

chr(65)

C

65+''

D

'+65

解答：

ord是将字符串首字母转换成ascii值； chr将ascii转换成字母

### 第二题

以下哪个选项是使用select函数检查读超时的正确用法（）

A

if (select(sockfd + 1,&fs,NULL,NULL,&timeout) == 0)

B

if (select(sockfd,NULL,&fs,NULL,&timeout) == 0)

C

if (select(sockfd + 1,NULL,&fs,NULL,&timeout) == 0)

D

if (select(sockfd ,&fs,NULL,NULL,&timeout) == 0)

解答：

select是网络编程中的io复用实现并发服务器的一个函数，第一个参数是最大套接字描述符加一，第二个是可读集合，第三个是可写集合，第四个是`&hellip;`忘了，第五个是超时处理。

### 第三题

下面程序的输出结果是（）

```c
#include <stdio.h>
int main() { 
  int intArray[] = {1, 2, 3, 4, 5}; 
  int *p = (int *)(&intArray+1); 
  printf("%d,%d",*(intArray+1),*(p-1)); 
  return 0; 
}
```

A

1,5

B

1,6

C

2,4

D

2,5

解答：

主要是要理解这句话：int *p = (int *)(&intArray+1); 

  intArray：是数组的首地址， 

  &intArray：就是存放这个数组首地址的地址,可用int (*)[5]的指针保存，


  &intArray+1：相当于int (*)[5]这个指针的指针偏移，偏移量是指向元素的大小*1，（比如double *p，p+1的偏移量就是一个double的大小*1）


  (int *)(&intArray+1)：相当于把偏移后的地址（也是一个int[5]）强转给p保存； 

  可得p指的是数组intArray结尾的下个地址，用二维数组理解的话就是intArray是第一个int[5]，即int[0][5]，p指向的是int[1][5]

### 第四题

以下程序的输出结果是（）

```c
main() {
  int a=4, b=5, c=0, d;
  d = !a&&!b||!c;
  printf("%d\n",d);
}
```

A

1

B

0

C

非0的数

D

-1

解答：

（!a&&!b）||!c，从左向右，！a=0之后！b不会被运算，但由于操作符‖,所以！c=1.    结果是0‖1=1

### 第五题

```c
char a=101;
int sum=200;
a+=27;sum+=a;
printf("%d\n",sum);
```

A

327

B

99

C

328

D

72

解答：

D  72. char类型的范围是-128---+127，当a+=27 ，之后a的值超出可表示范围会变为-128.

a为char型,-128~127,a=101,a+=27后溢出a=-128:
 a=127时不溢出    01111111(127补码)
 a+=1时溢出     10000000(-128补码)
                

 sum += a;
 sum为int型，a(char提升为int)
            10000000     -------->11111111 11111111  11111111  10000000(-128补码)

 所以,sum=200-128:00000000 00000000 00000000 11001000
            \+     11111111  11111111  11111111  10000000
  \----------------------------------------------------------------------------------
                 00000000 00000000 00000000 01001000  (64+8=72)

## 第十四天

### 第一题

如果传入函数的实参为数组名，则函数形参不能声明为（ ）

A

float a[];

B

float *a;

C

float a;

D

float (*a)[3];

解答：

A.float a[]是一个一维数组。数组作为形参接受实参为数组的传参当然是正确的 

  B.float *a是一个指针。数组名为该数组的首地址的指针，指针接受数组传参正确 

  C.float a 作为形参只能接受float 型变量名传参，本题实参为float数组名，错误 

  D.float (*a)[3]是一个数组指针，指向一行有3个float型数据的数组，指针作为形参接受传参正确

### 第二题

以下变量分配在BSS段的是（） 

```c
char s1[100];
int s2 = 0;
static int s3 = 0;
int main() {
  char s4[100];
}
```

A

s1

B

s2

C

s3

D

s4

解答：

BSS段：通常是指用来存放程序中**未初始化**的**全局变量**的一块内存区域； 

  数据段：通常是指用来存放程序中 **已初始化** **的** **全局变量** 的一块内存区域，static意味着在数据段中存放变量； 

  代码段：通常是指用来存放 程序执行代码 的一块内存区域； 

  堆：存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减，这一块在程序运行前就已经确定了； 

  栈：栈又称堆栈， 存放程序的 局部变量 （不包括static声明的变量）。除此以外，在函数被调用时，栈用来传递参数和返回值

## 第十五天

### 第一题

对于 32 位机器，则下面代码输出结果为（）

```c++
#include<iostream>
#include<string>
using namespace std;
typedef struct data_ {
  int a[10];
} data_t;
typedef struct descriptor_ {
  data_t* ptr;
  char data[0];
} desc_t;
int main() {
  cout << sizeof(desc_t) << endl;
  return 0;
}
```

 A

40

B

4

C

8

D

0

 解答：

data[0] 是一个柔性数组，柔性数组默认是不占用内存的，因此 desc_t 的大小即为指针大小，32 位机器上为 4 字节，无需额外对齐。

### 第二题

c++的一个类中声明一个static成员变量，下面描述正确的是（）

A

static是加了访问控制的全局变量，不被继承

B

类和子类对象，static变量占有一份内存

C

子类继承父类static变量

D

static 变量在创建对象时分配内存空间

 解答：AB

### 第三题

若有定义：int *p[3];，则以下叙述中正确的是（）

A

定义了一个基类型为int的指针变量p，该变量具有3个指针。

B

定义了一个指针数组p，该数组含有3个元素，每个元素都是基类型为int的指针。

C

定义了一个名为*p的整型数组，该数组含有3个int类型元素。

D

定义了一个可指向一维数组的指针变量p，所指一维数组应具有3个int类型元素。

解答：

由于"[]"的优先级比“*”高，所以p是一个含有3个元素的数组，其数据类型为int *，表示该数组的元素时基类型为int的指针，所以只有B是正确的。

### 第四题

在上下文和头文件正常的情况下,以下C语言指令：

```c
int a[5] = {1,3,5,7,9};
int *p = (int *)(&a+1);
printf("%d,%d",*(a+1),*(p-1));
```

A

2,1

B

3,1

C

3,9

D

运行时崩溃

解答：

*(a+1)其实很简单就是指a[1],输出为2. 问题关键就在于第二个点，*(p-1)输出为多少？ 解释如下，&a+1不是首地址+1，系统会认为加了一个整个a数组，偏移了整个数组a的大小（也就是5个int的大小）。所以int*p=(int*)(&a+1);其实p实际是&(a[5]),也就是a+5. 原因为何呢？ &a是数组指针，其类型为int(*)[5]; 而指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同，a是长度为5的int数组指针，所以要加5*sizeof(int)，所以p实际是a[5],但是p与（&a+1）类型是不一样的，这点非常重要，所以p-1只会减去sizeof(int*),a，&a的地址是一样的，但意思就不一样了，a是数组首地址，也就是a[0]的地址，&a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[5]。

### 第五题

C语言中浮点类型数据包括哪些部分（）

A

符号位

B

指数位

C

尾数部分

D

整数

E

小数

解答：浮点型在内存中分布为：符号位+指数位+尾数部分  

### 第六题

x是一个行列数均为1000二维数组，下面代码效率执行最高的是（）

A

`for(int j=0;j<1000;j++) for(int i=0;i<1000;i++) x[i][j]+=x[j][i];`

B

`for(int i=0;i<1000;i++) for(int j=0;j<1000;j++) x[i][j]+=x[j][i];`

C

`for(int i=0;i<1000;i++) for(int j=0;j<1000;j++) x[j][i]+=x[j][i];`

D

`for(int i=0;i<1000;i++) for(int j=0;j<1000;j++) x[i][j]+=x[i][j];`

解答：

选D. 主要是考察了CPU ***的预取操作，数组x[1000][1000]在内存中，是按行进行存储。D选项外部循环是按行进行，因此操作第i行时，会将第i行后面的部分数预取到***中，操作速度最快。 ABC选项其中都有跳列的操作，不能发挥***的预取操作功能。

## 第十六天

### 第一题

a - (b * c + d) / e的后缀表达式是（）

A

abcde-*+/

B

abcd*+e/-

C

abc*d+e/-

D

abc*de+/-

解答：

后缀表达式：先写运算对象再写符号，一般格式：{运算对象}{运算对象}{操作符} 

 

  `*bc** `

 

 ` bc\*d+ `

 

  `bc*d+e/ `

 

`abc*d+e/-`

### 第二题

```c++
#include <bits/stdc++.h>
using namespace std;
int main(){
  int n = 1001;
  int ans = 0;
  for(int i = 1; i <= n; ++i){
    ans ^= i % 3;
  }
  cout << ans << endl;
}
```

则上述程序输出为（）

A

-2

B

0

C

1

D

2

解答：

for循环中的ans ^= i % 3 可得出ans的值是以 1 3 3 2 0 0 六个数循环的，即6n的值为0，6n - 1 也为0，1001 = 6n - 1，故答案为B 

### 第三题

设有说明int s[2]={0,1},*p=s; 则下列错误的C语句是 （    ）。

A

s+=1;

B

p+=1;

C

*p++;

D

(*p)++;

解答：

答案：A，数组名为指针常量，其值不可更改。

### 第四题

strcpy()过程能够防止字符串被拷贝到较小的内存区域中去。

A

是

B

否

解答：

这是一个误解。实际上，`strcpy()`函数本身并不能防止字符串被拷贝到较小的内存区域中。`strcpy()`函数是C语言中的一个字符串拷贝函数，它将一个字符串从源地址复制到目标地址，直到遇到字符串结束符'\0'。但是，`strcpy()`函数本身并不会检查目标地址的大小。  如果目标地址的内存空间比源字符串的长度小，那么`strcpy()`函数将会产生缓冲区溢出，导致未定义的行为。这可能会覆盖其他重要的数据，破坏程序的稳定性和安全性。  为了避免这种情况，应该使用更安全的字符串拷贝函数，如`strncpy()`，它允许指定要复制的最大字符数目，从而避免缓冲区溢出。但是需要注意，`strncpy()`函数在目标字符串长度不足时不会自动添加字符串结束符'\0'，因此需要手动添加。  另外，更好的做法是使用更安全的字符串操作函数，如`strlcpy()`、`memcpy()`或者考虑使用更现代的编程语言，如C++，它提供了更安全的字符串处理机制。

### 第五题

设已定义浮点型变量data，以二进制代码方式把data的值写入输出文件流对象outfile中，正确的语句是（）

A

outfile.write((double ) &data, sizeof(double));

B

outfile.write((double ) &data, data);

C

outfile.write((char *) &data, sizeof(double));

D

outfile.write((char *) &data, data);

解答：

这里考察的是write的第二种用法： 

  write(const char* str, int n) 

  其中，str是字符指针或字符数组，用来存放一个字符串；n是int型数，它用来表示输出显示字符串中字符的个数。

### 第六题

C语言结构体类型变量在程序执行期间（）

A

所有成员一直驻留在内存中

B

只有一个成员驻留在内存中

C

部分成员驻留在内存中

D

没有成员驻留在内存中

解答：

结构体变量不管其包含有多少个成员，都应当看成是一个整体。在程序运行期间，只要在变量的生存期内，所有成员一直驻留在内存中，不可能出现有的成员驻留内存，有的成员不驻留内存的情况。故选择答案是A。

### 第七题

以下不正确的定义语句是（  ）。

A

double x[5] = {2.0, 4.0, 6.0, 8.0, 10.0};

B

char c2[] = {'\x10', '\xa', '\8'};

C

char c1[] = {'1','2','3','4','5'};

D

int y[5+3]={0, 1, 3, 5, 7, 9};

解答：

单纯的反斜杠默认为八进制，最多到7  

## 第十七天

### 第一题

有如下一段程序：

```c
int f1(float);
int f2(char);
int f3(float);
int f4(float);
int (*pf)(float);
```

则以下不合法的是（）

A

int (*p)(float) = &f1;

B

pf = &f4;

C

pf = &f2;

D

pf = f3;

解答：

函数指针所指向的函数，返回值类型，形参列表必须完全匹配，对函数指针赋值可以采用以下方式pf＝&p1或者pf＝p1

### 第二题

下述赋值语句错误的是（）。

A

a=(b=(c=2，d=3))

B

i++

C

a／b=2

D

a=a<a+1

解答：

选C   A: 逗号语句是以最后一条为返回值的，语句等价于''c=2;a=b=d=3;"，即"c=2;d=3;b=d;a=b;"是正确的   B: i++是自增，即"i+=1;"，也类似于赋值语句eg: for(int i=1;i<=n;i++);   C: 不能把一个返回值赋值，应为 a=b*2;//a=b<<1; /*if(!b)*/a=2/b;   D: (a<a)是一个bool型的值，会被强制转化为int型，而(a<a)不可能，故必为false，转化为0，+1后转化为a的数据类型并赋与a，等价于 bool a=true; int/*long/long long/short*/ a=1; char a=char(1);//一个笑脸 故选C

### 第三题

```c
void main (void) {
  int i ;
  i = 0x10 + 010 + 10;
  printf ("x = %x", i); 
}
```

程序的输出是（）

A

x = 34

B

x = 22

C

x = 28

D

都不是

解答：

ox10是16进制，换成十进制是16；010是八进制，换成十进制是8；16+8+10＝34；％x是以16进制输出，34换成16进制就是22

### 第四题

```c
#include <stdio.h>
int fun(int * data) {
  *data = *data % 2;
  return (*data) + 1;
}
int main() {
  int data = 12;
  fun(&data);
  printf("%d,", data);
  data = fun(&data);
  printf("%d", data);
}
```

程序运行后的输出结果是（）

A

0,0

B

0,1

C

1,2

D

12,13

解答：

&data取地址，所以fun函数运行过后data的值会改变，第一次变为0，第二次是将函数值返回付给data，因此0+1等于1. 

### 第五题

如下哪一段代码不能给地址0xaae0275c赋值为1?()

A

volatile int *p = (int *)0xaae0275c;*p = 1

B

(volatile int *)0xaae0275c[0] = 1

C

volatile int *p = (int *)0xaae0275c;p[0] = 1

D

*(volatile int *)0xaae0275c = 1

解答：

主要考察赋值到指定的内存地址 选项A，C， 通过一个指针向其指向的内存地址写入数据。 选项D，这行代码其实和上面的两行代码没有本质的区别。先将地址0xaae0275c强制转换，告诉编译器这个地址上将存储一个int类型的数据；然后通过钥匙“*”向这块内存写入一个数据。 选项B，将一个右值赋给一个左值，显然行不通。类似指针，int *p; p=1不合理 另外这里涉及到volatile关键字，顺便介绍一下 ： （1）用来同步，因为同一个东西可能在不同的存储介质中有多个副本，有些情况下会使得这些副本中的值不同，这是不允许的，所以干脆用volatile，让它只 有一个，没有其他的副本，这样就不会发生不同步的问题。 （2）防止编译器优化去掉某些语句，像我在arm中见到个寄存器非常奇怪，当中断来的时候，相对应的位置1，而清0又不能向这位写0，向这位写1才是1才 是清中断（清0）， // 假设0x560012300 为寄存器地址 #define INTPAND *(volatile unsigned int *)0x560012300 INTPAND = INTPAND; // 清中断 像编译器如果看到有INTPAND = INTPAND;这种看似无用的操作，如果没有volatile说明，编译器就很有可能会去掉INTPAND = INTPAND;实际上有用的东 西，却被编译器当没用的东西优化掉了。 （3）当地址是io端口的时候，读写这个地址是不能对它进行缓存的，这是相对于某些嵌入式中有***才有这个。比如写这个io端口的时候，如果没有这个 volatile,很可能由于编译器的优化，会先把值先写到一个缓冲区，到一定时候 再写到io端口，这样就不能使数据及时的写到io端口，有了volatile说明以后， 就不会再经过***,write buffer这种，而是直接写到io端口，从而避免了读写 io端口的延时。

### 第六题

```c
void main(void) {
  char *s = "1314520";
  int v1 = 0, v2 = 0, v3 = 0, v4 =0;
  for (int i = 0; s[i]; i++) {
    switch(s[i]) {
      default: v4++;
      case '1': v1++;
      case '2': v2++;
      case '3': v3++;
    }
  }
  printf("%d, %d, %d, %d", v4,v1,v2,v3)
}
```

上述代码段的输出为（）

A

3,5,6,7

B

7,7,7,7

C

7,2,1,1

D

0,2,1,1

解答：

char*s = "1314520"; 

  v1 = 0, v2 = 0, v3 = 0, v4 =0; 

第一次循环： 

i = 0，s[0]=1，switch(1)，进入case'1': v1++,v1=1;因为没有break，所以继续执行，case'2': v2++,v2=1; case'3': v3++,v3=1; 执行i++，i=1; 

第二次循环：        

 i = 1，s[1]=3，switch(3)，进入case'3': v3++,v3=2; 执行i++，i=2;           

第三次循环：            

i = 2，s[2]=1， switch(1)，进入case'1': v1++,v1=2;因为没有break，所以继续执行，case'2': v2++,v2=2; case'3': v3++,v3=3; 执行i++，i=4;               

第四次循环：               

i = 3，s[3]=4， switch(4)，进入default: v4++;v4=1；因为没有break，所以继续执行， case'1': v1++,v1=3; case'2': v2++,v2=3;case'3': v3++,v3=4;执行i++，i=4;                   

第五次循环：                  

i = 4，s[4]=5， switch(5)， 进入default: v4++;v4=2；因为没有break，所以继续执行，case'1': v1++,v1=4;case'2': v2++,v2=4;case'3': v3++,v3=5;执行i++，i=5;                       

第六次循环：                     

i = 5，s[5]=2， switch(2)， 进入case'2': v2++,v2=5;因为没有break，所以继续执行， case'3': v3++,v3=6; 执行i++，i=6;                           

第七次循环：                        

i = 6，s[6]=0，switch(0)，进入default: v4++;v4=3；因为没有break，所以继续执行case'1': v1++,v1=5;case'2': v2++,v2=6;case'2': v3++,v3=7; 执行i++，i=7; 跳出循环，打印v4,v1,v2,v3     

## 第十八天

### 第一题

设有以下函数
int f(int a, char * b) {„„}
则下面对函数指针的定义和赋值错误的是（ ）

A

int (*p)(int, char*); p=f;

B

int *p(); p=f;

C

int (*)p(); p=&f;

D

int *p(int, char);p=&f;

解答：

**函数指针的定义格式为函数类型(\*指针变量名)(形参列表)**

### 第二题

以下叙述中正确的是（）

A

在语句char str[] = "string!";中，数组str的大小等于字符串的长度

B

语句 char str[10] = "string!"; 和 char str[10] = {"string!"}; 并不等价

C

对于一维字符数组，不能使用字符串常量来赋初值

D

对于字符串常量 "string!"，系统已自动在最后加入了"\0"字符，表示串结尾

解答：

字符串中的字符依次存储在内存中一块连续的区域内，并且把空字符 ' \0' 自动附加到字符串的尾部作为字符串的结束标志。故字符个数为 n 的字符串在内存中应占（ n+1 ）个字节。 B 选项中两者等价， C 选项中可以使用字符串常量来给一维字符数组赋值，就像 B 选项中一样， A 选项中数组长度比字符串长度小一个字节，字符串中包含隐含的结尾符。

### 第三题

以下叙述中正确的是（）

A

数组下标的下限是1

B

数组下标的下限由数组中第一个非零元素的位置决定

C

数组下标的下限由数组中第一个被赋值元素的位置决定

D

char c1, c2, *c3, c4[40];是合法的变量定义语句

解答：

数组下标的下限是 0 。因此 D 选项正确。

### 第四题

若x和y均定义为int型，z定义为double型，以下语句错误的是（）

A

scanf("%d%lx,%le",&x,&y,&z);

B

scanf("%2d * %d%lf"&x,&y,&z);

C

scanf("%x %* d%o",&x,&y);

D

scanf("%x%o%6.2f",&x,&y,&z);

解答:

scanf输入double时只接受le或lf，不接受f，所以D是错误的;%*d表示读入一个整数，但是并不存储，所以C是正确的(输入三个数，第一个数赋值给x，第三个数赋值给y，第二个数省略)

D错误因为输入数据时不能规定精度

### 第五题

语句char *p="Turbo C"的含义是将字符串赋给字符型指针变量p。请问这句话的说法是正确的吗？

A

正确

B

错误

解答：

P是一个指向字符串的指针变量，只能存放地址。上述语句的作用是将一个字符串常量的首地址赋给字符指针变量P。注意，是地址，地址，地址。

### 第六题

下列程序执行后的输出结果是（）

```c
int main() {
  char x = 0xFFFF;
  printf("%d\n",x--);
}
```

A

-32767

B

FFFE

C

-1

D

-32768

解答：

可以把它想象成无符号表示的整数，char占一个字节8 bit，范围0~255（0x0~0xff） 

  但是对于有符号整数来说，最高位为1意味着是负数所以从128~255（0x80~0xff）是负数，因为（0xff+0x01=0x00）即-1+1=0所以0xff应该对应有符号整数-1，相应有0xfe对应-2，。。。。0x80对应-128 

  因此选C 

### 第七题

能够把指定长度的字节序列插入到输出流中的函数是（）

A

put

B

write

C

cout

D

print

解答：

write函数所在的头文件为 <unistd.h> 

  write有两种用法。一种是： 

  ssize_twrite(int handle, void *buf, int nbyte); 

  handle 是[文件描述符](http://baike.baidu.com/view/1303430.htm)； 

  buf是指定的缓冲区，即[指针](http://baike.baidu.com/view/159417.htm)，指向一段内存单元； 

  nbyte是要写入文件指定的字节数；返回值：写入文档的字节数（成功）；-1（出错） 

  write函数把buf中nbyte写入文件描述符handle所指的文档，成功时返回写的字节数，错误时返回-1. 

  另一种是：write（const char* str,int n) 

  str是[字符](http://baike.baidu.com/view/263416.htm)指针或字符[数组](http://baike.baidu.com/view/209670.htm)，用来存放一个字符串。n是int型数，它用来表示输出显示字符串中字符的个数。 

  write（"string",strlen("string");表示输出[字符串常量](http://baike.baidu.com/view/260048.htm)

### 第八题

请指出以下程序的错误：

```c
void GetMemory(char **p, int num){
  if(NULL == p && num <= 0)//1
    return;
  *p = (char*)malloc(num);
  return;
}
void main(void){
  char *str = NULL;
  GetMemory(&str, 80); //2
  if(NULL != str){
    strcpy(&str, "hello"); //3
    printf(str);
  }
  return true; //4
}
```

A

1

B

2

C

3

D

4

解答：

 if(NULL==p && num<=0)//1 应该为 if(NULL==p || num<=0) 

 strcpy(&str,"hello"); //3  应为 strcpy(str,"hello"); 
 return true; //4  与void冲突

## 第十九天

### 第一题

设 int a,b,c; 执行表达式 a=b=1 ; a++ ; b+1 ; c=a+b-- ; 后， a,b 和 c 的值分别是

A

2,1,2

B

2,0,3

C

2,2,3

D

2,1,3

解答：

B a=b=1后a、b为1 a++后a为2，b为1 b+1无任何赋值，a为2、b为1 c=a+b--首先执行c=a+b，a为2、b为1、c为3 然后执行b--，a为2、b为0、c为3

### 第二题

下列程序的输出结果为（ ）

```c
int main() {
  int m = 7, n = 4;
  float a = 38.4, b = 6.4, x;
  x = m/2 + n*a/b + 1/2;
  printf("%f\n", x);
  return 0;
}
```

A

27.000000

B

27.500000

C

28.000000

D

28.500000

解答：

x=m/2+n*a/b+1/2; 

 

  先是以各自的类型进行计算，m/2位3, n*a/b=24.000000 1/2=0，然后转成float型

### 第三题

下列描述，正确的一共有多少个？

1)const char *p，这是一个常量指针，p的值不可修改

2)在64位机上，char *p= “abcdefghijk”; sizeof(p)大小为12

3)inline会检查函数参数，所以调用开销显著大于宏

4)重载是编译时确定的，虚函数是运行时绑定的；

A

1

B

2

C

3

D

4

解答：

  A错误 ：**左定值，右定向**。 char * const p；//**p这个字符指针所指向的值才不会改变。**
      

​    *B错误* ：***首先第一点 ： 在程序中这样写 是会编译报错的 ：******char \*p= “abcdefghijk”;***  ***//这里的字符串是常量指针，const char \* p = "asdas";才不会报错。第二点 sizeof（p）返回的是8， 这个8指的是char \*这个指针类型在64位机器上的大小，而不是12。***      

​    *C错误* ： **错在显著这个字眼上，inline确实会检查函数参数，保证编译器对于他的正确调用。inline确实会提高效率，原因在于没有了调用开销，而它与宏定义相比，更多的在于它提供了更多的安全性**。

### 第四题

求输出结果 

```c
#include<stdio.h>
int a[2][2][3] = {{{1, 2, 3}, {4, 5, 6}}, {{7, 8, 9}, {10, 11, 12}}};
int *ptr = (int *)(&a + 1);
int main(){
printf("%d %d", *(int*)(a + 1), *(ptr - 1));
}
```

A

7 12

B

1 6

C

1 3

D

7 9

解答：

1. &a+i = a + i*sizeof(a); 2. a+i = a +i*sizeof(a[0]);

`*(int*)(a+1) `指向数组  a[2]  的第二个元素中的第一个，也就是内部第二层大括号的第一个元素

  *(ptr-1)整个数组的最后一个元素，因为  (int *)(&a+1);  指向整个数组的下一个位置

 &a是个四级指针，指向的是a这样的数组，所以它加1，就会跳过整个数组，然后int化，减1只减一个int



  a是一个三维数组的地址，  它加1，就会跳过最高层数组，跳到7

### 第五题

对于函数重载，下面说法错误的是（）

A

函数名不同，但形参的个数与类型相同

B

函数名相同，但形参的个数与类型不同

C

函数名相同，但形参的个数与类型也相同

D

函数名相同，返回值不同，与形参无关

解答：

**函数重载(overload)**是指**多个函数使用相同的函数名**。函数重载是多态性的体现，即使用同一个函数名实现多种函数调用。 

  调用重载函数时，C++编译器根据函数的**实参类型**来确定所调用的函数。因此，重载函数定义时，必须使彼此在**参数个数** **或** **参数类型**上有所不同。 

  在调用同名函数时，编译器怎么知道到底调用的是哪个函数呢？编译器是根据函数调用语句中实参的个数和类型来判断应该调用哪个函数的。因为重载函数的参数表不同，而调用函数的语句给出的实参必须和参数表中的形参个数和类型都匹配，因此编译器才能够判断出到底应该调用哪个函数。

**仅返回值不同，不能定义为重载函数**。因为C++允许 return 语句返回的表达式的类型与函数的类型不同（这时由系统做自动强制类型转换），在函数调用时编译器并不关心函数的返回值类型，而在函数返回时才涉及函数的返回值类型。 

   

   

  此外，还需注意两点： 

  （1）**不允许重载main() 函数**，因为main()函数是C++程序执行的唯一入口 

  （2）函数重载时，**避免使用形参的默认值**。 

### 第六题

print函数声明为

```c
void print(int a,char b='b',int c=1);
```

下面函数调用正确的是（）

A

print('a');

B

print(5,8);

C

print(5,'#');

D

print(5,'#',2);

解答：

```c
print('a');//对应97，b,1
print(5,8);//对应5，退格符号，1 如果在print中输出a,b,c的话，会得到1，因为退格会删除5
print(5,'#');//对应5，#，1
print(5,'#',2);//对应5，#，2
```

## 第二十天

### 第一题

若char a[10];已定义，以下语句中不能从键盘上给 a 数组的所有元素赋值的语句是（ ）

A

gets(a);

B

scanf("%s",a);

C

for(i=0;i<10;i++)a[i]=getchar();

D

a=getchar();

解答：

getchar：不管你输入字符串有多长，每次只能获取一个字符型变量； 

 

  假如想使用getchar给a中所有元素输入值，需要按照C选项的形式，而不能整体输入；

### 第二题

一个双目运算符作为类的成员函数重载时，重载函数的参数表中有()个参数。

A

1

B

2

C

3

D

0

解答：

答案：A 重载为类成员函数时，类本身是该双目运算符的一个参数，所以还需要一个参数 如果重载为友元函数则需要两个参数

### 第三题

下列程序的运行结果是YY，78，96 ，请为横线处选择合适的程序（）

![img](https://uploadfiles.nowcoder.com/images/20170120/6642697_1484899223618_4F91842A04B0AF67549CDEFC8A38F674)

A

a

B

*a

C

a[]

D

&a

解答：

A.a 是肯定不行的，他是标准的形参，出去函数体之后，实参还是原来的实参，值不变。 

  B *a是正确， 

  C a[] 也是正确的  《答案是BC，此题有误》 

  D &a 这样的传参方式也对，但是此时函数输入的形式应该是f(c),而不是f(&c)，此外函数体里的引用形式应该是a.的形式，而不是a-> 

### 第四题

若有以下声明和定义

```c
union dt {
  int a;
  char b;
  double c;
} data;
```

以下叙述中错误的是（）

A

data的每个成员起始地址都相同

B

变量data所占内存字节数与成员c所占字节数相等

C

程序段：data.a=5;printf("%f\n",data.c);输出结果为5.000000

D

data可以作为函数的实参

解答：

执行“data．a=5；printf(“％f\n”,data．C)；”printf函数只是将内存中的数据以不同的类型输出，而不能将内存中的整型数据自动转换为等值的浮点数，故C是错误的。 

  在内存中，实数与整数的存放形式完全不一样，共用体的成员共用的是同一块内存，而不是同一个数值，因此选项C是错误的。

### 第五题

已知year为整型变量，不能使表达式(year % 4 == 0 && year % 100 != 0) || year % 400 == 0的值为"真"的数据是（）

A

1990

B

1992

C

1996

D

2000

解答：

程序翻译一下就是 四年一闰 百年不闰 四百年补闰  

  A 1990%4=2(!0)不是闰年  

  B 1992%4==0(0)是闰年 

  C 1996%4==0(0)是闰年 

  D 2000%4==0(0)&&2000%400==0(0)是闰年

### 第六题

以下程序段的输出结果是（）

```c
char s[] = "\\141\141abc\t";
printf("%d\n", strlen(s));
```

A

9

B

12

C

13

D

14

解答：

**1、**strlen统计字符串长度时,是以'\0'作为字符串结束的标志的。也就是说，不论是在字符串中还是字符串尾，要遇到'\0'，就认为字符串结束，不再继续统计字符串长度。 

 \：\\连用，标志一个反斜杠字符  

   1  

   4  

   1  

   \141：\ddd标志三位八进制  

   a  

   b  

   c  

   \t  

### 第七题

当宏定义需要定义多行代码时，会使用下列哪个符号（）

A

|

B

/

C

\

D

\-

解答：

在行尾放一个 \ ，编译器会忽略行尾的换行符，起到续行的作用。

### 第八题

以下代码执行后，it的数据为（）

```c++
std::list<int> temp;
std::list<int>::iterator it = temp.begin();
it = --it;
```

A

未知

B

temp.end()

C

异常

D

NULL

解答:

这个是双链表容器啊，前驱和后继逻辑上的相邻，地址并不相邻呀，迭代器减，是在地址上减减的，就异常了

## 第二十一天

### 第一题

分析以下函数，该函数的功能是（）

```c
void sca_from_file(int a[], int n, char fn[])
{
  FILE *fp;
  int i;
  fp = fopen(fn, "r");
  for (i = 0; i < n; i++)
  {
    fscanf(fp, "%d", &a[i]);
  }
  fclose(fp);
}
```

A

打开文件fn，从文件中读出n个整数到数组a中

B

打开文件fn，将数组a的n个元素写到文件中

C

打开文件fn，从文件中读出n，再读n个整数到数组a中

D

打开文件fn，将n和数组a的n个元素依次写到文件中

解答：

fscanf通过文件指针fp从文件流中读取数据，一次读取一个整数，共读取n次；但有个疑问，fclose的位置应该在for循环之后的。 选A

### 第二题

若有以下定义和赋值语句，则与&s[i][j]等价的是（）

```c
int s[2][3] = {0}, (*p)[3], i, j;
p = s;
i = j = 1;
```

A

*(*(p+i)+j)

B

*(p[i]+j)

C

*(p+i)+j

D

(*(p+i))[j]

解答：

int (*p)[3]可以看出p是数组的指针，p=*s说明p指向的是s[0]数组。[]符号的优先级高于&符号，`&s[i][j]`是`s[i][j]`的地址。`*(p + i) + j`与`&s[i][j]`等价。

### 第三题

```c
void main(void) { 
  int a=b=c=10;
  a=b=c=50;
  printf(“\n %d %d %d”,a,b,c);
}
```

程序的输出是（）

A

50 50 50

B

编译错误

C

10 10 10

D

都不是

解答：

int a=b=c=10 bc没定义

int a int b a=b=10 才定义

### 第四题

已知 i=3 ，则 printf("%d", -i++); 的输出结果为（ ）

A

-4

B

-3

C

-2

D

以上均不对

解答：

负号运算符优先级高于自增运算符优先级，应为（-3）++ i++是先赋值后i+1，表达式值为i，i的值为i+1； ++i是先i+1，后赋值，表达式值为i+1，i的值为i+1

答案为b

### 第五题

以下函数用法正确的个数是：

```c
void test1(){
  unsigned char array[MAX_CHAR+1],i;
  for(i = 0;i <= MAX_CHAR;i++){
    array[i] = i;
  }
}
char*test2(){
  char p[] = "hello world";
  return p;
}
char *p = test2();
void test3(){
  char str[10];
  str++;
  *str = '0';
}
```

A

0

B

1

C

2

D

3

解答：

第一个问题： 重点不在于CHAR_MAX的取值是多少，而是在于i的取值范围是多少。 一般char的取值范围是-128到127，而u char 则是0~255，所以i的取值范围是0~255. 所以当CHAR_MAX常量大于255时，执行i++后，i不能表示256以上的数字，所以导致无限循环。 第二个问题： 重点在于函数中p的身份，他是一个指针，还是数组名； 如果是指针p，则p指向存放字符串常量的地址，返回p则是返回字符串常量地址值，调用函数结束字符串常量不会消失（是常量）。所以返回常量的地址不会出错。 如果是数组p，则函数会将字符串常量的字符逐个复制到p数组里面，返回p则是返回数组p，但是调用函数结束后p被销毁，里面的元素不存在了。 例子中p是数组名，所以会出错，p所指的地址是随机值。 若是把char p[]="hello";改成char *p="hello";就可以了。 第三个问题： 重点在于str++;这实际的语句就是str=str+1;而str是数组名，数组名是常量，所以不能给常量赋值。（可以执行str+1，但是不能str=.）

### 第六题

如下C语言程序段：

```c
for(k=0; k<1000; k++)
 a[k] = a[k]+32;
```

若数组a及变量k均为int型，int型数据占4B，数据Cache采用直接映射方式，数据区大小为1KB、块大小为16B，该程序段执行前Cache为空，则该程序段执行过程中访问数组a的Cache缺失率约为 （）

A

1.25%

B

2.5%

C

12.5%

D

25%

解答：

分析语句“a[k]=a[k]+32”：首先读取a[k]需要访问一次a[k]，之后将结果赋值给a[k]需要访问一次，共访问两次。第一次访问a[k]未命中，并将该字所在的主存块调入Cache对应的块中，对于该主存块中的4个整数的两次访问中只在访问第一次的第一个元素时发生缺失，其他的7次访问中全部命中，故该程序段执行过程中访问数组a的Cache缺失率约为1/8（即12.5%）。

### 第七题

有以下说明语句：

```c
struct Student {
  int num;
  double score;
};
Student stu[3] = {{1001,80}, {1002,75}, {1003,91}}, *p = stu;
```

则下面引用形式错误的是（）

A

p->num

B

(p++).num

C

(p++)->num

D

(*p).num

解答：

B缺少一个*，*.=-> 

### 第八题

int a=5,则 ++(a++)的值是?

A

5

B

6

C

7

D

编译出错

解答：

a++返回一个值也就是5 



  ++操作符只能作用于变量，而不能是一个数字 你可以试试 ++5

```
++ 是一目运算符，自增运算，它只能用于一个变量.
表达式归根结底是一个定值，所以不能用于表达式
```

## 第二十二天

### 第一题

已知字母a的ASCII十进制代码为97，则执行下列语句后的输出结果为（ ）

```c
char a = 'a';
a--;
printf("%d,%c\n", a + '2' - '0', a + '3' -'0');
```

A

b,c

B

a--运算不合法,故有语法错

C

98,c

D

格式描述和输出项不匹配,输出无定值

解答：

首先 %d 打印的是个整数，所以选c，其次， a+'2'-'0 这句话可以直接看做是 ’a‘-1 后的ASCII值 +2，也就是98，第二个 %c 打印的是字符型，所以是字母，a+'3'-'0 可以看做是 ‘a’-1 往后挪了三位，即 ‘c’

### 第二题

设有定义：

```c
struct complex {
  int real, unreal;
} data1 = {1, 8}, data2;
```

则以下赋值语句中错误的是（ ）？

A

data2=(2,6);

B

data2=data1;

C

data2.real=data1.real;

D

data2.real=data1.unreal;

解答：

结构体变量建议在定义的时候进行初始化。结构体常见的几种初始化方法如下： (1)struct a a1 = { .b = 1, .c = 2 }; (2)struct a a1 = { b:1, c:2 }; (3)struct a a1 = { 1, 2}; 计算机内核喜欢用第一种，使用第一种和第二种时，成员初始化顺序可变。因此，可以判断选项 A 错误。

### 第三题

```c
#include <stdio.h>
void func(char *p) { p = p + 1; }
int main() {
  char s[] = {'1', '2', '3', '4'};
  func(s);
  printf("%c", *s);
  return 0;
}
```

以下程序执行后的输出结果为（）

A

2

B

编译错误

C

1

D

无法确定

解答：

不是指针，不会改变原来的大小

 p是一个指针，s也是一个指针，指针传指针，还是相当于值传递，函数调用时将s的内容（即字符'1'的地址）拷贝给p，p+1不会对s产生任何影响。想要达到改变s的目的，需要用到指针的指针，代码得这样写：
 \#include<stdio.h>

 void func(char **p)
 {
 *p=*p+1;
 }
 int   main()
  {
 char s[]={'1','2','3','4'};
 func(&s);
  printf("%c",*s);  //此时输出2
 return 0;
 }
 还有一点要说的是，题目代码的第9行应该是printf("%c",*s);，否则，按题目的写法，答案将是无法确定。

### 第四题

下列 C 代码中，不属于未定义行为的有：______。

A

int i=0; i=(i++);

B

char *p="hello"; p[1]='E';

C

char *p="hello"; char ch=*p++;

D

int i=0; printf("%d %d\n",i++,i--);

E

都是未定义行为

F

都不是未定义行为

解答：

未定义行为（Undefined Behavior）是指C语言标准未做规定的行为。同时，标准也从没要求编译器判断未定义行为，所以这些行为有编译器自行处理，在不同的编译器可能会产生不同的结果，又或者如果程序调用未定义的行为，可能会成功编译，甚至一开始运行时没有错误，只会在另一个系统上，甚至是在另一个日期运行失败。当一个未定义行为的实例发生时，正如语言标准所说，“什么事情都可能发生”，也许什么都没有发生。一句话，未定义行为就是运行结果不确定
1.变量即是左边结果，又是右边的操作数，如a+=a++，a %= b ^= a ^= b ^= a
2.使用越界数组也是C的一个“未定义行为”
3.允许一个随便指的指针的读写。
4.使用未初始化的变量

### 第五题

一个C语言的执行下面说法正确的是（）

A

本程序的主函数开始，到本程序的主函数结束

### 第六题

下列关于 clone 和 fork 的区别描述正确的有？

A

clone和fork最大不同在于fork不再复制父进程的栈空间，而是自己创建一个新的。

B

clone和fork最大不同在于clone不再复制父进程的栈空间，而是自己创建一个新的。

C

clone是fork的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等

D

fork是clone的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等

解答：

答案C 解释： fork() 函数复制时将父进程的所以资源都通过复制数据结构进行了复制，然后传递给子进程，所以 fork() 函数不带参数； clone() 函数则是将部分父进程的资源的数据结构进行复制，复制哪些资源是可选择的，这个可以通过参数设定，所以 clone() 函数带参数，没有复制的资源可以通过指针共享给子进程

### 第七题

有转义字符如下：
'\0X41'、'\0x41'、'\X41'、'\x41'、'\a'、'\b'、'\c'、'\r'
其中错误的转义字符个数是（）

A

0个

B

2个

C

4个

D

6个

解答：

正确答案选C 

  字符集为每个字符分配了唯一的编号，每个字符除了用它本身的实体表示外，还可以用转义字符来表示 

  转义字符以\开始，如果是\x(注意是小写，C语言是区分大小写的)开头，后面接16进制数，如果以\开头，后面接八进制数。 

  转移字符表示的数据范围有限，因此对\x开头的 ，只能是\xxx(后面两位表数据)这种格式的，意思是只能接两位数据,最大值为\x7f 

  对\开头的，后面可以接三位数据，即\xxx(后三位均为数)，最大值为\177 

 另外，还有其他几个常见的转义字符， 

  \t ,\n,\a,\b,\r,\f,\v 

### 第八题

以下正确的说法是（  ）。

A

用户调用标准库函数前，必须重新定义

B

若已包含标准库头文件及相关命名空间，用户也可以重新定义标准库函数，但是该函数将失去原有含义

C

若已包含标准库头文件及相关命名空间，则系统不允许用户重新定义标准库函数

D

用户调用标准库函数前，不必使用预编译命令将该函数所在文件包括到用户源文件中

解答：

A：用户调用标准库函数，必须利用#include来对其进行声明。  

B、C：标准库函数可以被重载而不能重新定义，重载后函数具有不同的形参，但是原有的定义并不失效。  

D：当用户调用标准库函数前，必须使用#include预编译命令将函数所在文件包括到用户源当中。  

## 第二十三天

### 第一题

若要重载+、=、<<、==和[]运算符，则必须作为类成员重载的运算符是



A

+和=

B

=和<<

C

＝＝和<<

D

＝和[]

解答：

答案 D 解释：      (1)只能使用成员函数重载的运算符有：=、()、[]、->、new、delete。      (2)单目运算符最好重载为成员函数。      (3) 对于复合的赋值运算符如+=、-=、*=、/=、&=、!=、~=、%=、>>=、<<=建议重载为成员函数。      (4) 对于其它运算符，建议重载为友元函数。 运算符重载的方法是定义一个重载运算符的函数，在需要执行被重载的运算符时，系统就自动调用该函数，以实现相应的运算。也就是说，运算符重载是通过定义函数实现的。运算符重载实质上是函数的重载。重载运算符的函数一般格式如下：      函数类型 operator 运算符名称 (形参表列)      {      对运算符的重载处理      } 重载为类成员函数时参数个数=原操作数个数-1（后置++、--除外） 重载为友元函数时 参数个数=原操作数个数，且至少应该有一个自定义类型的形参

### 第二题

下列说法正确的是（）

A

float的指数取值范围是-127，+128

B

float的取值范围是-3.4E+38,3.4E+38

C

float的指数位有8位

D

float的尾数位有23位

解答：

> 浮点型数据类型，FLOAT 数据类型用于存储单精度浮点数或双精度浮点数。浮点数使用 IEEE（电气和电子工程师协会）格式。
> **浮点类型的单精度值具有 4 个字节，包括一个符号位、一个 8 位 二进制指数和一个 23 位尾数。**由于尾数的高顺序位始终为 1，因此它不是以数字形式存储的。此表示形式为 float 类型提供了一个大约在 -3.4E+38 ~ 3.4E+38 之间的范围。

构成

> 浮点数在机内用指数型式表示，分解为：**数符，尾数，指数符，指数**四部分。
> 数符占 1 位二进制，表示数的正负。
> 指数符占 1 位二进制，表示指数的正负。
> 尾数表示浮点数有效数字，0.xxxxxxx, 但不存开头的 0 和点。
> 指数存指数的有效数字。

### 第三题

在上下文及头文件均正常的情况下，执行下面语句后的输出为

```c
int I = 1;
if(I <= 0)
  printf("****\n");
else
  printf("%%%%\n");
```

A

%%

B

****

C

有语法错，不能正确执行

D

%%%%

解答：

在printf中的%作为转义符，两个%才相当于1个% 

### 第四题

设有定义语句

```c
int x[6] = {2, 4, 6, 8, 5, 7}, *p = x, i;
```

要求依次输出x数组6个元素中的值，不能完成此操作的语句是（）



A

for(i=0;i<6;i++) printf("%2d",*(p++));

B

for(i=0;i<6;i++) printf("%2d",*(p+i));

C

for(i=0;i<6;i++) printf("%2d",*p++);

D

for(i=0;i<6;i++) printf("%2d",(*p)++);

解答：

分两类：1.指针移动取值  *++p相当于*(++p) ，*(p++)相当于*p++  。  2.元素取值  (*p)++  ，++(*p*)*

### 第五题

以下叙述中正确的是（）

A

'\0' 表示字符 0

B

"a" 表示一个字符常量

C

表达式：'a' > 'b' 的结果是 假;

D

`'\"' `是非法的

解答：

【解析】 A 选项中， '\0' 表示结束； B 选项中，字符常量是用单引号括起来的一个字符； D 选项中， '\"' 是双引号符。因此 C 选项正确。

### 第六题

以下选项中可作为C语言合法常量的是（）

A

-80.

B

-080

C

-8e1.0

D

-80.0e

解答：

C语言中实数常数的科学表示法规定格式为：“实数e整数”或“实数E整数”，其中幂是整数，不能写成实数。e(或E)前后的实数和整数都不能省略掉，因此选项C和D都是错误的。选项B的-080，由于C语言规定。0开头的是八进制数，0x(0x)开头的是十六进制数。而八进制数数字是0～7，出现8是错误的，因此选项B也是错误的。只有选项A是正确的。实数的小数点前后的数字都可以不写。

### 第七题

函数rewind的作用是（）

A

使位置指针重新返回文件的开头

B

将位置指针指向文件中所要求的特定位置

C

使位置指针指向文件的末尾

D

使位置指针自动移至下一个字符位置

解答：

【解释】rewind函数的作用就是将文件位置指针重新指向文件的开始位置。故正确答案是A.

### 第八题

math.h的abs返回值()

A

不可能是负数

B

不可能是正数

C

都有可能

D

不可能是0

解答：

答案是C  因为负数的范围比正数大一个,比如8位的二进制，可以表示范围为-128~127 所以abs(-128)可能并不能表示为128 所以只能返回原值 

## 第二十四天

### 第一题

如果c为字符型变量，判断c是否为空格（假设已知空格ASCII码为32）不能使用（）

A

if(c==32)

B

if(c=='32')

C

if(c=='\40')

D

if(c==' ')

解答：

**A. if(c==32)** 

  **这个选项是正确的。在ASCII编码中，空格的值就是32，因此使用if(c==32)可以正确判断变量c是否为空格。** 

  **B. if(c=='32')** 

  **这个选项是错误的。'32'表示一个包含两个字符的字符串，而不是一个字符。因此，这个表达式并不表示空格字符的ASCII码，因此不能正确判断变量c是否为空格。** 

  **C. if(c=='\40')** 

  **这个选项也是错误的。在C语言中，\40表示八进制数，而不是ASCII码。所以这个表达式并不正确地表示空格的ASCII码，因此不能正确判断变量c是否为空格。** 

  **D. if(c==' ')** 

  **这个选项是正确的。空格字符的表示就是' '，因此使用if(c==' ')可以正确判断变量c是否为空格。**

### 第二题

在下列选项中，全部都合法的浮点型数据的选项为（）

A

1e3.5 15. 2e4

B

12.34 1e+5 0.1E12

C

0.2e2 12345. e5

D

5.0e（1+4） 0.1 8e+2

解答：

浮点型数据有两种表达方式，一种是我们常见的十进制小数，如1.0等，可以**缺省小数点前后的数**，比如 1.和.1也是合法的表达；另一种就是指数型了，形如 aEn 的方式，其中**a是一个十进制小数**，诸如1.0 .123456或者1.都是合法的，中间的**E和e也都合法，不区分大小写**，最后一个**n只能是整型常量，不能是表达式**。**a和n都不能缺省。**
  A 错在1e3.5 指数不能是3.5 

  B 正确，其中第二项中的 +5表示正数，完全正确 

  C e5错误 

  D 5.0e（1+4） 错误，不能是表达式

### 第三题

32位机器上，以下结构的sizeof(P)为（）

```·c
struct A {
  int a;
  char b;
  int c;
  char d;
};
struct P {
  struct A w[2];
  short b;
  struct A* p;
}
```

A

26

B

38

C

40

D

30

解答：

/*考察结构体对齐和填充： 

  结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如果不是，编译器会自动在成员间填充。*/ 

  struct A { 

  int a;              //4 bytes 

  char b;            //1 bytes 

  //char pad[3]        //3 bytes 

int c;              //4 bytes

  char d;            //1 bytes 

  //char pad[3]       //3 bytes 

  }              // total = 16 bytes 

 /* P中有结构体A的成员，但是计算时按照A中数据类型确定的*/ 

 struct P {
struct A w[2];  // 2 * 16 bytes

  short b;      //2 bytes 

  //char pad[2]  //2 bytes 

struct A* p;   //4 bytes
} // total = 40 bytes

### 第四题

在Windows 32位操作系统中，假设字节对齐为4，对于一个空的类A，sizeof(A)的值为（）？

A

0

B

1

C

2

D

4

解答：

肯定不是A.0  C++对空类或者空结构体 ,对其sizeof操作时候,默认都是 1个字节.所以答案 选B

### 第五题

有以下程序

```c
#include <stdio.h>
int main() {
  int i = 1;
  i = i ^ i;
  printf("%d\n", i);
  return 0;
}
```

程序运行后的输出结果是？

A

1

B

-1

C

0

D

7

解答：

本题考查位运算中按位异或运算符,异或运算只有在两个比较的位不同时其结果是1,否则结果为0,i^i运算符两边相同,所以结果为0,选项C正确。

### 第六题

已知有声明为int x=2，下列表达式中值不为8的是（）

A

x+=2,x*2

B

x+=x*=x

C

(x+7)/2*((x+1)%2+1)

D

x*7.2/x+1

解答：

D选项中int型和double型混合运算，整型会自动转成double型再进行运算。2.0*7.2/2.0+1.0=8.2

### 第七题

执行下面代码段

```c
int i = 10, j = 2;
i *= j + 8;
```

后i的值为28。请问这句话的说法是正确的吗？

A

正确

B

错误

解答：

 i *= j+8 

 

  i = i *(j+8) 

 

  i = 10*(2+8) 

 

  i = 100; 

### 第八题

在C语言系统中，假设int类型数据占2个字节，则double、long、unsigned int、

char类型数据所占字节数分别多少（）

A

8,2,4,1

B

2,8,4,1

C

4,2,8,1

D

8,4,2,1

解答：

C语言系统中，如果int型数据占2个字节，则说明该系统是16位的系统，

此时double型数据占8个字节，long型数据占4个字节，unsigned int占2个字节，char

型数据占1个字节，所以选择D。

## 第二十五天

### 第一题

下面两个结构体

```c
struct One{
  double d;
  char c;
  int i;
}
struct Two{
  char c;
  double d;
  int i;
}
```

在#pragma pack(4)和#pragma pack(8)的情况下，结构体的大小分别是

A

16 24,16 24

B

16 20,16 20

C

16 16,16 24

D

16 16,24 24

解答：

 \#pragma pack(4)情况下
 one:4*2+（1+3）+4=16
 two :(1+3+)4*2+4=16

 pack 8情况下
 one：8+（1+3+4）=16
 two: (1+7)+8+(4+4)=24

### 第二题

设C语言中，一个int型数据在内存中占2个字节，则unsigned int型数据的取值范围为

A

0~255

B

0~3267

C

0~65535

D

0~2147483647

解答：

int、unsigned int 所占字节数相同，所以unsigned int 也占2个字节。

   unsigned int 2个字节也就是16位范围是0到2^16-1   

​    int 最高位为符号位，只能表示-32768~32767， unsigned int  无符号位，可以表示0~65535 

类型取值范围计算：

char类型占一个字节，一个字节8个比特位。计算机中储存数字储存的是补码，正数的原返补相同； 1.当char是无符号的时：8个比特位分布为 0000 0000 为最小值0，而当8个比特位分布为 1111 1111 时为最大值即2^8-1=255； 2.当char是有符号类型时：最高比特位为符号位，因此在数值上的最大值为111 1111 即2^7-1=127； 那么，还剩下一个比特位为符号位，那不就表示 取值范围为 -127—127吗，怎么会是-128呢； 3.接下来谈谈-128的由来： 理由一：-127-127总共有255个数字，而8个比特位共有256中排列组合，在有符号类型中 0000 0000 表示数值为+0(暂且这么描述)，1000 0000 表示数值为-0，那么一个0有两种表示，很显然浪费了一种排列组合1000 0000，那么多出来的位置怎么才不浪费呢？ -127-127都有对应的表示了，1000 0000最高位为1表示负数，那么只能往下安排了，即(规定，规定，规定)100 0000表示-128；

### 第三题


若要以写方式打开当前目录下文件 abc.txt，则以下语句正确的是（）。

A

fopen("abc.txt","r");

B

fopen("abc.txt","w");

C

fopen("abc.txt",'r');

D

fopen("abc.txt",'w’);

解答：

读写加双引号

### 第四题

字符串“a+b=20\n”的长度是（）

A

7

B

8

C

5

D

6

解答：

是求字符串长度，没有问占用的内存长度 

### 第五题

若有int c;，则while(c=getchar());是正确的 C 语句。请问这句话的说法是正确的吗？

A

正确

B

错误

解答：

**getchar **

   getchar由宏实现:#define getchar() getc(stdin)。getchar有一个int型的返回值。当程序调用getchar时.程序就等着用户按键。用户输入的[字符](https://baike.so.com/doc/2529629-2672477.html)被存放在键盘[缓冲区](https://baike.so.com/doc/2576817-2721104.html)中。**直到用户按回车为止**(回车字符也放在缓冲区中)。当用户键入回车之后，getchar才开始从stdio流中每次读入一个字符。getchar函数的返回值是用户输入的字符的ASCII码，若文件结尾(End-Of-File)则返回-1(EOF)，且将用户输入的字符[回显](https://baike.so.com/doc/2692478-2842876.html)到屏幕。如用户在按回车之前输入了不止一个字符，其他字符会保留在键盘缓存区中，等待后续getchar调用读取。也就是说，后续的getchar调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完后，才等待用户按键。  

  **getch **

   getch与getchar基本功能相同，差别是getch直接从键盘获取键值，不等待用户按回车，只要用户按一个键，getch就立刻返回，getch返回值是用户输入的ASCⅡ码，出错返回-1。输入的字符不会[回显](https://baike.so.com/doc/2692478-2842876.html)在屏幕上.getch函数常用于[程序调试](https://baike.so.com/doc/5797319-6010114.html)中，在调试时，在关键位置显示有关的结果以待查看，然后用getch函数暂停程序运行，当按[任意键](https://baike.so.com/doc/6881981-7099471.html)后程序继续运行。  

   这个版本忽略了个重点，getch()是非缓冲输入函数，就是不能用getch()来接受缓冲区已存在的字符，如以下C++程序段，运行时如果输入1 2 3 a时必须用getchar()才能在后面程序获得正常输入，即使先前已经恢复流了，此处用getch()是万万不行的。  

  **getche** 

   这个函数与前两上类似，功能也相近，都是输入一个[字符](https://baike.so.com/doc/2529629-2672477.html)，返回值同样是输入字符的ASCII码，但不同的是，此函数在输入后立即从控制台取字符，不以回车为结束(带回显)。

### 第六题

下列说明中 const char *ptr；ptr应该是（）

A

指向字符常量的指针；

B

指向字符的常量指针；

C

指向字符串常量的指针；

D

指向字符串的常量指针；

解答：

如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。

### 第七题

声明一个指向含有10个元素的数组的指针，其中每个元素是一个函数指针，该函数的返回值是int，参数是int*，正确的是（）

A

(int *p[10])(int*)

B

int [10]*p(int *)

C

int (*(*p)[10])(int *)

D

int ((int *)[10])*p

E

以上选项都不正确

解答：

C.  首先题目说要声明一个数组指针,  一般我们想到的数组指针是 随便来一个 int(*p)[10],   然后又说每个元素是一个函数指针,那么我们随便来一个 函数指针  int (*pf)(int *) . 然后把(*p)[10]作为一个整体替代 pf   即  int(*(*p)[10]))(int *);   分析:  判断一个复杂式子看最高优先级的,*p是一个指针,然后(*p)外面是[],所以是数组指针,(*p)[10])描述完毕,然后再看外面int(*)(int *)很明显,这是一个函数指针,所以这个数组中每个元素是函数指针 ... 

### 第八题

在同一个源文件中，外部变量与局部变量同名，则在局部变量的作用范围内，外部变量不起作用

A

TRUE

B

FALSE

解答：

局部变量的作用域内会覆盖同名的全局变量

## 第二十六天

### 第一题

下面关于#import和#include描述正确的是

A

\#import和#include不可以混合使用

B

\#import只用于引用Objective-C的文件，#include只用于Ｃ和C++的文件

C

\#import和#include的使用效果完全相同

D

\#import是#include的替代指令，防止重复引用

解答：

Objective-C：#import
C，C++：#include
 \#import由gcc编译器支持
 在Objective-C 中，#import 被当成 #include 指令的改良版本来使用。除此之外，#import确定一个文件只能被导入一次，这使你在递归包含中不会出现问题。
使用哪一个还是由你来决定。一般来说，在导入 Objective-C 头文件的时候使用 #import，包含C 头文件时使用#include。                                    

#import比起#include的好处就是不会引起交叉编译

### 第二题

在上下文和头文件均正常情况下，以下程序的输出结果是？

```c
int x = 1;
do{
  printf("%2d\n",x++);
}while(x--);
```

A

1

B

无任何输出

C

2

D

陷入死循环

解答：

Do while为出口循环，也就是先执行循环体，再进行出口判断，若为false则跳出循环

### 第三题

语言中哪一种形式声明了一个指向char类型变量的指针p，p的值不可修改，但p指向的变量值可修改？

A

const char *p

B

char const *p

C

char*const p

D

const char *const p

解答：

const 限定一个数据为只读属性。
1.const char p; 限定变量 p 为只读。
2.const char *p; p 为一个指向 char 类型的指针，const 限定 p 指向的数据为只读。所以 *p 的值不能被修改，而指针变量 p 本身的值可以被修改。
3.char * const p; 限定此指针变量为只读，所以 p 的值不能被修改，而 *p 的值可以被修改。
4.const char *const p; 两者皆限定为只读，不能修改。

const 出现在*左边，表示的是p所指的变量内容不可变，指针指向可以改变，也就是顶层const 

  const 出现在*右边，表示的是p是一个指针常量，不能指向其他的变量，但是指向的变量的内容可以改变，底层const 

  const在*左右两边都出现，表示指针指向不能改变，所指的变量内容也不能改变

### 第四题

char *p="girl" ；的含义是定义字符型指针变量p，p的值是字符串"girl"。（）

A

正确

B

错误

解答：

char *p="girl"; p是字符串首地址 *p是girl &p是地址值  

### 第五题

如果在基类中将show声明为不带返回值的纯虚函数，正确的写法是（）

A

virtual show()=0；

B

virtual void show()；

C

virtual void show()=0；

D

void show()=0 virtual；

解答：

纯虚函数的格式：virtual 返回值类型 函数名(参数列表) = 0;

### 第六题

有函数定义：

```c
void test(int a){} 
void test(float a){} 
```

则以下调用错误的是：

A

test(1);

B

test(‘c’);

C

test(2+’d’)；

D

test(0.5)；

解答：

D 0.5类型模糊，既匹配int类型也匹配float类型

错了 ，0.5是double类型  ，应该写成0.5f    

### 第七题

下列关于bool,int,float,指针类型的变量a 与“零”的比较语句正确的有？

A

bool : if(!a)

B

int : if(a == 0)

C

float: if(a == 0.0)

D

指针: if(a == nullptr)

解答：

由于计算机二进制表示浮点数有精度的问题，0.0(浮点double)实际上不是0，而是非常接近零的小数，所以C错！ 

  在ANSIC C中定义了FLT_EPSILON/DBL_EPSILON/LDBL_EPSILON来用于浮点数与零的比较，一般if(fabs(a)<FLT_EPSILON)或if(fabs(a)<          DBL_EPSILON)就可以表示a是否“为0”。而if(a==0.0)是永远不会成立的，达不到要求！

### 第八题

通过return语句，函数可以具备一个或一个以上的返回值。（）

A

正确

B

错误

解答：

只能有一个返回值. 
 但是这个返回值可以是一个结构体或者是一个类,而结构体和类中可以容纳很多信息. 
 或者你也可以参考函数参数的方式来实现返回你所需要的信息,可以是多个

## 第二十七天

### 第一题

定义宏

```#define DECLARE(name, type) type name##_##type##_type```

则DECLARE(val, int)替换结果为（）

A

int val_int_type

B

int val_int_int

C

int name_int_int

D

int name_int_name

解答:

 \##是一种分隔连接方式，它的作用是**先分隔，然后进行强制连接**   

  “name”和第一个`“_”`之间被分隔了，所以预处理器会把name##_##type##_type解释成4段：“**name**”、`“_”`、“**type**”以及“**_type**”，name和type会被替换，而_type不会被替换

### 第二题

执行"int x=1;int y=~x;"语句后,y的值为？

A

1

B

0

C

-1

D

-2

解答：

假设int占2个字节，那么1的二进制表示是 0000 0001 ，~表示按位取反，则 0000 0001变为 1111 1110，在计算机中整数用补码形式表示，正数的补码是它本身，负数的补码是原数值除符号位按位取反再加一，由补码求原数值也是按位取反再加一，那么 1111 1110 除符号位按位取反再加一变成 1000 0010，即 -2。 

### 第三题

函数strlen("ASDFG\n")的值是7。（）

A

正确

B

错误

解答：

/n为转义字符， 占一个字节，ASDFG为5个字节，strlen()计算字符串的长度时不会计算隐藏的/0，所以是5+1  6个 sizeof()会计算/0字符 

### 第四题

下面代码在32位计算机中输出的结果是（）

```c
struct TEST_TYPE {
  int a;
  int b;
};
int testSize(struct TEST_TYPE val[10]) {
  return sizeof(val);
}
```

A

4

B

8

C

10

D

80

解答：

子函数中传递的数组被当成指针对待，sizeof()以后只是一个指针的大小

### 第五题

静态外部变量只在本文件内可用。请问这句话的说法是正确的吗？

A

正确

B

错误

解答：

在外部变量的定义前面加上关键字static，就表示定义了一个外部静态变量。外部静态变量具有全局的作用域和全局的生存期，定义成static类型的外部变量将无法再使用extern将其作用范围扩展到其他文件中，而是被限制在了本身所在的文件内，为程序的模块化、通用性提供方便。

### 第六题

执行以下语句，输出结果为（）

```c
#include<stdio.h>
int main( ) {
char *p1 = "hello";
char *p2 = "world";
char *p3 = "a piece of cake";
char *str[] = {p1, p2, p3};
printf("%c", *(str[0] + 1));
}
```

A

world

B

hello

C

编译时错误

D

其他选项都不正确

解答：

char*p1="hello"; 

  char*p2="world"; 

  char*p3="a piece of cake"; 

  char*str[]={p1,p2,p3}; 

  printf("%c",*(str[0]+1)); 

  str[0] 为p1 p1指向的是"hello" p1指针+1 前进一位指向字符e。最后输出e

### 第七题

在C语言中，函数的隐含存储类别是（）

A

auto

B

static

C

extern

D

无存储类别

解答：

如果在函数定义中没有说明extern或static，则隐含为extern。正确答案是C

### 第八题

以下程序的运行结果是（)

```c
#include <stdio.h> 
int main() { 
  int sum, pad,pAd; 
  sum = pad = 5; 
  pAd = ++sum, pAd++, ++pad; 
  printf("%d\n",pAd); 
}
```

A

5

B

6

C

7

D

8

解答：

由于赋值运算符的优先级高于逗号表达式，因此

```
pAd = ++sum, pAd++, ++pad;
```

等价于

```
(pAd = ++sum), pAd++, ++pad; 
```

sum 先自增然后赋值给 pAd，pAd 为 6，然后 pAd 自增变为 7。

逗号表达式的结果为最后一个表达式的值，因此正确答案为 C

## 第二十八天

### 第一题

对于以下变量定义，正确的赋值是（）

```c
int *p[3], a[3];
```

A

p=a

B

*p=a [0]

C

p=&a [0]

D

p[0]=&a[0]

解答：

A选项：虽然两个数组是不同的，但关键点是**数组的地址不可修改**，所以错误 B选项：两边的元素类型不一样，左边是指针，右边是int，当然不可以。  B选项题意应该是想把指针数组里的第一个指针(数组名代表首元素名)指向a[0]，改为*p=&a[0]即可实现。 

  C选项：把a的首元素地址赋给了p数组，同样犯了A的错误。 

  D选项：指针数组的第一个指针指向int数组的第一个值 

### 第二题

```c
enum string{   
  x1,   
  x2,   
  x3 = 10,   
  x4,   
  x5,   
} x;
```

函数外部访问x等于什么？

A

5

B

12

C

0

D

随机值

解答：

**全局变量时初始化为0，局部变量时初始化为随机值。**

### 第三题

循环语句 while(!E); 中的表达式 !E 等价于_______



A

E!=0

B

E!=1

C

E==0

D

E==1

解答：

这一题可以这么理解：将 E 看做一个可以等于任何一个值的变量。运用特殊例子进行排除； 

  A选项：若E==0时  ，则！E 为true ,而 E!=0为false 所以排除。 

  B选项：若E==2时  ，则！E为false,而E!=1 为true 所以排除。 

  C选项：无论E取什么!E 与E＝＝0  都同为true 或false。所以符合。 

  D选型：若E==1时  ，则！E 为false ,而E==1 为true 所以排除。

### 第四题

若有语句：`int s[3][3]`,(*p)[3];p=s;则对s数组元素的引用形式正确的是__________

A

p+1

B

*(p+1)

C

`p[1][2]`

D

*(p+1)+2

解答：

在二维数组中，二维数组的数组名是代表首元素的地址，而**二维数组的首元素是二维数组第一行的内容** 

  所以在p中存储的地址是s第一行一维数组的地址。（在看二维数组时，我们要将其当做一维数组来看）

  其次，我们知道，数组名代表的是首元素的地址，我们访问数组中的元素一般用arr[1]的形式；但是从地址的角度来看：*(arr + 1)也能访问到数组中同样的元素；所以我们可以得到：**arr[1] 就等价于\*(arr + 1)。**（实际上在原理上确实是这样的，比较复杂，有兴趣的可以去查一下） 

  知道了这些知识后，我们再来看C选项：`**p[1][2] `就可以写为 \*(\*(p + 1) + 2)，即为访问第二行第三个元素。** 

  （而B选项只是访问的二维数组第二行的元素；A和D选项不符合基本的格式）

### 第五题

以下叙述中正确的是（）

A

对于逻辑表达式：a++ || b++，设a的值为1，则求解表达式的值后，b的值会发生改变

B

对于逻辑表达式：a++ && b++，设a的值为0，则求解表达式的值后，b的值会发生改变

C

else不是一条独立的语句，它只是if语句的一部分

D

关系运算符的结果有三种：0，1，-1

解答：

B选项和A选项中，对于逻辑表达式，其中b的值不会因为表达式的结果发生改变；D选项中，关系运算符的结果有"真"和"假"两种。因此C选项正确。

### 第六题

在C语言中以下正确的说法正确的是（ ）

A

实参和与其对应的形参各占用独立的存储单元

B

实参和与其对应的形参共占用一个存储单元

C

只有当实参和与其对应的形参同名时才共占用存储单元

D

形参是虚拟的，不占用存储单元

解答：

函数调用时将实参值传递给形参。如果占用同一片空间的话，编译时候就不存在实参形参类型不匹配的报错，而且在参数传递中，形参值的改变不会影响实参的值，所以是各自占独立存储单元

### 第七题

以下程序的运行结果是（）

```c
#define MIN(x,y)  (x)<(y) ? (x):(y)
int main() {
  int i = 10, j = 15, k;
  k = 10*MIN(i, j);
  printf("%d\n", k);
}
```

A

10

B

15

C

100

D

150

解答：

语句k=10*MIN(i,j)；在预编译时将进行宏替换为k=10*(i)<(j) ? (i) : (j)；。

因i=10，j=15，所以语句等价于k=10*10<15 ? 10:15；，10*10比15大，因此k的值

将是15。故正确答案是B。

### 第八题

在32位小端的机器上，如下代码输出是什么：

```c
char array[12] = {0x01, 0x02, 0x03,0x04, 0x05 , 0x06, 0x07, 0x08};   
short *pshort = (short *)array;   
int *pint = (int *)array;   
int64 *pint64 = (int64 *)array;   
printf("0x%x , 0x%x , 0x%llx , 0x%llx", *pshort , *(pshort+2) , *pint64 , *(pint+2));
```

A

0x201 ， 0x403 ， 0x807060504030201 ， 0x0

B

0x201 ， 0x605 ， 0x807060504030201 ， 0x0

C

0x201 ， 0x605 ， 0x4030201 ， 0x8070605

D

0x102 ， 0x506 ， 0x102030405060708 ， 0x0

解答：

B。 

  小端机器的数据高位字节放在高地址，低位字节放在低地址。 

  char array[12] =  {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}; 

  1，char一字节，直观呈现的结果为：0x08-07-06-05-04-03-02-01**（从后到前下标为0-7）**； 

  2，short两字节，直观呈现  的结果  为：  0x0807-0605-0403-0201      **（从后到前**    **下标**  **为0-3）**  ：

  *pshort从0开始，所以0x201； 

  *(pshort+2)从2开始，所以0x605； 

  3，int64八字节，直观呈现  的结果  为  0x0807060504030201      **（从后到前**    **下标**      **为0）**    ：

  *pint64从0开始，所以0x807060504030201； 

  4，int四字节，直观呈现为0x08070605-04030201**（从后到前**  **下标**  **为0-1）**  ：

  *(pint+2))从2开始，但是最多只到下标1，后面位置默认为0

## 第二十九天

### 第一题

若有以下说明和定义语句：

```c
union uti {
  int n;
  double g;
  char ch[9];
} struct srt {
  float xy;
  union uti uv;
} aa;
```

考虑内存对齐，则变量aa所占内存的字节数是（    ）

A

9

B

8

C

24

D

13

解答：

union中最大字节对齐类型为double，8字节。所以struct中应以double为标准对齐，并且分配给union的空间应该>=9字节，综上，float需要一个8字节存储，union需要两个8字节存储，共需3*8=24字节。

### 第二题

以下程序输出（）个“-”

```c
int main(void) {
  int i;
  for (i = 0; i < 2; i++) {
    fork();
    printf("-");
  }
  return 0;
}
```

A

2

B

4

C

6

D

8

解答：

这道题考的是子进程和行缓冲 printf（“- \n”）直接会输出一个 “-” 而printf("-")没有换行符不会直接输出，会放在缓冲区中等到程序结束后由系统处理输出  第一次循环中经过fork后有两个进程 经过printf("-")之后两个进程缓冲区中都有一个“-” 第二次进入循环经过fork后会有四个进程，且由于fork出的子进程会复制父进程的缓冲区，这时四个进程都有一个"-" 再经过printf("-")之后四个进程都有两个"-" 这时程序结束时会将缓冲区的内容全部输出，即8个"-"

### 第三题

下列选项中能够正确表示逻辑“异或”运算的是：

A

a||b

B

a&b

C

(a&&b)&&!(a||b)

D

(a||b)&&!(a&&b)

解答：

异或运算可以描述为当且仅当a、b两个操作数中一真一假时结果才为真，其他情况均为假。A和B分别时或运算和与运算，优先排除掉。假定a=1 b=0分别带入C和D，C的结果是（1&&0）&&！(1||0)等价于0&&！1等价于0排除C。带入D中结果为（1||0）&&!(1&&0)等价于1&&！0等价于1，答案为D。

### 第四题

下面是对s的初始化，其中不正确的是（    ）

A

char s[5]={"abc"};

B

char s[5]={'a','b','c'};

C

char s[5]=" ";

D

char s[5]="abcdef";

解答：

S[5]里面最多有4个元素，还有一个是结束符！

### 第五题

对于代码段

```c
#define D 2 
int x = 5;
float y = 3.83;
char c = 'D'; 
```

则下面选项中错误的是（ ）

A

x++;

B

y++;

C

c++;

D

D++;

解答：

d是因为我们不能对宏进行取地址操作，而++操作是先从内存取值到寄存器 然后寄存器加一后再写入内存中必然涉及如地址操作

### 第六题

下面表达式（本题数值均为十进制）

```c
11|10
```

的结果是（）

A

11

B

10

C

8

D

2

解答：

‘|’ 该符号是按位或运算，我们首先需要把他转换成二进制： `1011|1010 -->1011 //按位运算，有1出1 无 1出0 ` 最后结果就是 1011 转成10进制  => 11...展开 

### 第七题

以下 scanf 函数调用选项中， **错误** 的是（）

```c
struct T {
  char name[20];
  int age;
  int sex;
} a[5], *pa=a;
```

A

scanf("%s",a[0].name);

B

scanf("%d", &pa[0].age);

C

scanf("%d",&(pa->age));

D

scanf("%d", pa->age);

解答：

选D。该题考察的是通过scanf函数的调用对结构体数据类型进行初始化。  scanf("输入控制符", 输入参数); 功能：将从键盘输入的字符转化为“输入控制符”所规定格式的数据，然后存入以输入参数的值为地址的变量中。 scanf输入时，要将值放到地址里，所以要加上&，所以B、C正确。 name属于字符数组的数组名，相当于数组的首地址，所以A正确。 pa->age属于输出语句获取值的形式，所以D错误

### 第八题

当参数*x=1, *y=1, *z=1时，下列不可能是函数add的返回值的( )?

```c
int add(int *x, int *y, int *z){
  *x += *x;
  *y += *x;
  *z += *y;
  return *z;
 }
```

A

4

B

5

C

6

D

7

解答：

D 开始不知道啥意思，后经牛客网的大神指点才知道这题要考虑的是，x，y，z三个参数是否指向同一地址（或者说调用该函数时是否实参相同），如：当a=b=c=1时，add(&a,&a,&a)，add(&a,&b,&c)。 通过写程序测试得出结果，不可能得到答案7。 有以下5种情况

## 第三十天

### 第一题

下面对枚举变量的定义不正确的是（）

A

enum weekday{sun,mou,tue,wed,thu,fri,sat}; enum weekday a,b,c;

B

enum weekday{sun,mou,tue,wed,thu,fri,sat}a,b,c;

C

enum weekday{sun,mou,tue,wed,thu,fri,sat};

D

enum {sun,mou,tue,wed,thu,fri,sat}a,b,c;

解答：

**声明枚举变量三种方法**

**1、先声明枚举类型后定义枚举类型变量**

```c
enum WeekdayType  
{  
    sun,mou,tue,wed,thu,fri,sat 
};  
enum WeekdayType today,yesterday,tomorrow;
```

**2、声明枚举类型的同时定义枚举类型变量**

```c
enum WeekdayType  
{  
    sun,mou,tue,wed,thu,fri,sat   
}today,yesterday,tomorrow;
```

**3、直接定义枚举类型变量**

```c
enum  
{  
    sun,mou,tue,wed,thu,fri,sat  
}today,yesterday,tomorrow;
```

### 第二题

设有 int x=11; 则表达式 (x++ * 1/3) 的值是（ ）

A

3

B

4

C

11

D

12

解答：

x++是在；之后执行的，相当于(x*1/3)；x++； 

 (x*1/3)表达式算出的结果值为Int类型，自动去小数点 

 结果为3

### 第三题

在32位系统里，int b[ ][3] = {{1},{3,2},{4,5,6},{0}};中，sizeof(b) = ？

A

4

B

12

C

28

D

48

解答：

 b为4行3列的二维数组，12*4 = 48

### 第四题

有如下C语言程序段

```c
short si = -32767;
unsigned short usi = si;
```

执行上述两条语句后，usi的值为 （）



A

-32767

B

32767

C

32768

D

32769

解答：

结合题干及选项可知，short为16位。因C语言中的数据在内存中为补码表示形式， si对应的补码二进制表示为：1000 0000 0000 0001B，最前面的一位“1”为符号位，表示负数，即-32767。由signed型转化为等长unsigned型数据时，符号位成为数据的一部分，也就是说，负数转化为无符号数（即正数），其数值将发生变化。Usi对应的补码二进制表示与si的表示相同，但表示正数，为32769。

### 第五题

代码int i=3；i<<=4;i的值等于多少？（）

A

40

B

110000（二进制）

C

12

D

-48

解答：

<<是左移运算符的意思，左移运算符是用来将一个数的各二进制位全部左移若干位。  这里可以理解为把3化为2进制，然后统一左移4位。  3的二进制比如  0011  左移4位  110000 = 48   

### 第六题

若有“ float a[3]={1.5,2.5,3.5},*pa=a;*(pa++)*=3; ”，则 *pa 的值是（）。

A

1.5

B

2.5

C

3.5

D

4.5

解答：

 *pa=a;指针pa指向a[0]; 

  pa++;pa++和++pa的区别知道吧，返回值仍是pa操作之前的值； 

  *(pa++)取pa只想的地址的值； 

  *(pa++)*=3;将该值变为原来的3倍，也就是数组a的第一个值为4.5； 

  由于pa++之后pa指针移动了size(float)个字节，所以pa指向a[1],所以值为2.5。

### 第七题

已知char *a[]={ "fortran", " basic", "pascal", "java", "c++" };，则cout<<a[3];的显示结果是（）

A

t

B

一个地址值

C

java

D

javac++

解答：

1.首先a是一个数组，数组里的内容是char型指针，指针指向字符串

2.cout一个char型指针会打印其中内容，而cout一个int型指针会打印其地址

3.cout一个char型指针的解引用会打印这个指针指向的内容即上述的'j'，cout一个int型指针的解引用也会打印这个指针指向的内容即上述的1314

4.char *ptr = "java";指针形式存储的字符串是字符常量，最好加上const，数组a也最好加上

### 第八题

下面程序段执行后的输出结果是（）（□表示一个空格）

```c
int a=3366;
printf("│%-08d│",a);
```

A

│-0003366│

B

│00003366│

C

│3366□□□□│

D

输出格式非法

解答：

%-08d表示输出占8个空格的位置，并且左对齐，所以正确的答案是C

## 第三十一天

### 第一题

引用标准库时，下面的说法正确的是（）

A

语句#include “stdlib.h”是正确的，而且程序编译速度比#include< stdlib.h >要快

B

语句#include< stdlib.h >是正确的，而且程序编译速度比#include “stdlib.h”要快

C

语句#include< stdlib.h >和#include “stdlib.h”都是正确的，程序编译速度没有区别

D

语句#include “stdlib.h”是错误的

解答：

`include <file>`  //在标准库及默认搜索目录中寻找将要 include 的文件 ； 

`include "file"`  //先在当前目录中搜索文件，然后再到默认搜索目录中搜寻。

### 第二题

"++"运算符的优先级比"+"运算符的优先低。请问这句话的说法是正确的吗？

A

正确

B

错误

解答：

++分为前置和后置，前置++比+运算优先级高，后置比+运算符优先级低。 例如:  b=1;a=++b+1;结果：a=3 b=1;a=1+b++;结果: a=2

### 第三题

若执行fopen函数时发生错误，则函数的返回值是（）

A

地址值

B

0

C

1

D

EOF

解答：

执行fopen函数时，如果文件打开成功，则返回该文件结构体的指针，如果

打开失败（例如，读打开时文件不存在，写打开时文件不能创建），则返回NULL（即0）。

故选择答案是B。

### 第四题

若有以下定义和语句：

```c
int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, *p = a;
```

则不能表示a数组元素的表达式是

A

*p

B

a[10]

C

*a

D

a[p-a]

解答：

答案：选B A的值为1 B越界 C和A相同 D p-a地址相减为0，访问数组第一个元素

B:以为数组的下标从0开始，所以10越界。

### 第五题

函数a定义如下: 

```c
int a(int tab){
  int n = tab-1;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  return n;
}
```

调用函数a(666)返回的结果是（）

A

1023

B

1024

C

666

D

528

解答：

想想按位或的特点是什么，原来是1的地方运算之后还是1，所以1只会多不会少，但是因为是使用了右移的结果进行运算，所以1最多也就填满传入的那个参数的所有bit，如果是左移不就最多可以把整个类型所占的bit全部置为1吗？所以只需要把665所占的bit数找出来，我们知道2^10=1024占11个bit即1 00000 00000，因为665小于1024大于512所以占10个bit，10个bit全1，当然是1023了。

### 第六题

若整型变量x的初值为6，则计算表达式“x+=x-=x*x”之后，x的值是（）

A

50

B

60

C

-50

D

-60

解答：

选D x+=x-=x*x x=6 x*x=36 x-=x*x 即为x=x-x*x，此时x=6-36=-30 x+=x-=x*x 即为x=x+(-30) =-30+(-30)=-60

### 第七题

执行完a=5 mod 3 语句后，a的值为？

A

0

B

2

C

3

D

5

解答：

B.2 mod运算，即求余运算，是在整数运算中求一个整数n除以另一个整数p的余数的运算，且不考虑运算的商

### 第八题

sizeof( double ) 是（）

A

一个整型表达式

B

一个双精度型表达式

C

一个不合法的表达式

D

一种函数调用

解答：

sizeof 是 C 语言中的一个操作符 (operator), 不是函数调用 , 简单的说其作用就是返回一个对象或者类型所占的内存字节数。所以选择 A 。

## 第三十二天

### 第一题

可在C程序中用作用户标识符的一组标识符是（    ）

A

nk ak-g2 #Fim 3h

B

W.D _total day student

C

C<D average while month

D

cher name addr class2

解答：

标识符的定义是： 

```c
1.标识符的第一个字符必须是字母或下划线，后面的字符可以是字母、数字或下划线，不能为其它字符。
2.标识符的长度可以是一个或多个字符，最长不允许超过32个字符。
3.标识符不能和C语言的关键字相同，也不能和用户自定义的函数或C语言库函数同名。

直接排除ABC，因此选D
```

### 第二题

C语言中，在头文件正常引用的情况下，执行

```c
printf("%5s", "abcdefg");
```

后，输出结果为

A

abcde

B

abcdefg

C

cdefg

D

输出错误信息

解答：

printf函数中，"%.5s"的意思是字符串最多输出5个字符。
 追问
 那如果是"%5s"的话是什么意思？
 追答
 "%5s"的意思是，输出至少5个字符，如果不够五个字符，左侧用空格补齐

### 第三题

以下代码输出什么?

```c
int a = 1, b = 32;
printf("%d,%d", a << b, 1 << 32);
```

A

1,1

B

1,0

C

0,0

D

取决于编译器

解答：

```c
执行a<<b时，编译器会先将b与31进行and操作，以限制左移的次数小于等于31。b&31=0，则a<<b=1
执行1<<32时，编译器直接执行算术左移的操作
```

### 第四题

下面程序运行结果为（）

```c
int main() {
  char c = 'a'；
  if('a' < c <= 'z') printf("Low”)；
  else printf("UP")；
}
```

A

LOW

B

UP

C

LOWUP

D

程序语法错误

解答：

关系运算符具有左结合性，所以表达式（’a'<c<=’z’)将先求’a'<c的值，即为

0（假），再求0<=’z’的值，即为1（真），所以执行if后面的语句printf（"LOW");故正确

答案为A。

### 第五题

以下程序运行时输入：123456789↙

则程序运行结果是（ ）

```c
#include <stdio.h>
int main()
{
  int x, y;
  scanf("%2d%*4s%2d", &x, &y);
  printf("%d", y - x);
  return 0;
}
```

A

44

B

55

C

66

D

88

解答：

%*4s表示读取一个长度为四个字符的字符串，中间的*表示将读取到的字符串忽略，不赋给变量列表中的变量

### 第六题

表达式(short)10/10.2*2运算后结果类型是（）

A

short

B

int

C

double

D

float

解答：首先，要注意是(short)10/10.2*2，而不是(short) (10/10.2*2)，前者只是把10强转为short，又由于式子中存在浮点数，所以会对结果值进行一个自动类型的提升，浮点数默认为double，所以答案是double；后者是把计算完之后值强转short。

### 第七题

已知int i=0, j=1, k=2;，则逻辑表达式++i||- -j&&++k的值为（  ）

A

0

B

1

C

2

D

3

解答：

++i||- -j&&++k和（++i）||（- -j&&++k）等价，先计算++i，短路特性后面的运算不进行了，最后i=1，j=1，k=2 

### 第八题

有如下类定义：

```c
class A {
  public:
    int fun1();
    virtual void fun2();
 
  private:
    int _a;
};
```

在32位机器上，请问sizeof(A)的值为：

A

12

B

8

C

4

D

1

解答:

选B 类的大小只与成员变量（非static数据成员变量）和虚函数指针有关，还要考虑到对齐. 所以类A的大小：4个字节（int _a）+4个字节（指向虚函数的指针）= 8个字节

## 第三十三天

### 第一题

\#include命令的功能是（）。

A

在命令处插入一个头文件

B

在文件首部插入一个头文件

C

在命令处插入一个文本文件

D

在文件首部插入一个程序文件

解答：

预处理器发现#include后，就会寻找指令后面<>中的文件名，并把这个文件的内容包含到当前的文件中，被包含的文件中的文本将替换源代码文件中的#include指令 

### 第二题

已知：int x，y；double z；以下语句中错误的函数调用是（）

A

scanf(“%d,%1x,%1e",&x,&y,&z)；

B

scanf(“%2d*%d%1f”,&x,&y,&z)；

C

scanf(“%x%*d%o”,&x,&y)；

D

scanf(“%x%o%6.2f",&x,&y,&z)；

解答：

  \* 是scanf函数中的一种修饰符，表示忽略该输入项，使用方法为：放在%与格式d（或者s，c等）之间。 

  如选项C： scanf(“%x%*d%o”,&x,&y)； 

  ~


  B只能获取x的值，y和z都不能正常获取，但是不会报错。 

  ~ 

  D：scanf不能指明浮点数的精度。

### 第三题

当顺利执行了文件关闭操作时，fclose函数的返回值是（）

A

-1

B

TRUE

C

0

D

1

解答：

如果正常关例了文件，则函数返回值为0；否则，返回值为非0。故选择答案是C。

### 第四题

在C语言源程序的开始处通常加上预处理命令 #include  <stdio.h> 的原因是（）

A

stdio.h文件中包含标准输入输出函数的函数声明，通过引用此文件以便能正确使用printf、scanf等函数

B

将stdio.h中标准输入输出函数的二进制代码插入到引用处，以便进行编译链接

C

将stdio.h中标准输入输出函数的源程序插入到引用处，以便进行编译链接

D

将stdio.h中标准输入输出函数链接到编译生成的可执行文件中，以便能正确运行

解答：

inlcude 语句的实质是，把相应的头文件copy到当前行。而且是预编译阶段就执行的。

答案为A

### 第五题


下列函数定义中，有语法错误的是（）

A

void fun(int x, int *y){*x *= *y;}

B

void fun(int *x, int y){*x += y;}

C

int * fun(int *x, int y){return x += y;}

D

void fun(int x, int *y){x *= *y;}

解答：

A：选项中，*x *= *y;开头的*x错了，改x*=*y  

对于整数而言，取其*是错误的，所以A错误

### 第六题

若a是float型变量，b是unsigned型变量，以下输入语句中合法的是（ ）

A

scanf("%6.2f%d", &a, &b);

B

scanf("%f%n", &a, &b);

C

scanf("%f%3o", &a, &b);

D

scanf("%f%f", &a, &b);

解答：

 ％d整型输出，％ld长整型输出，  

   ％o以八进制数形式输出整数，  

   ％x以十六进制数形式输出整数，  

   ％u以十进制数输出unsigned型数据(无符号数)。  

   ％c用来输出一个字符，  

   ％s用来输出一个字符串，  

   ％f用来输出实数，以小数形式输出，  

   ％e以指数形式输出实数，  

   ％g根据大小自动选f格式或e格式，且不输出无意义的零。  

   其中%o和%x都是二进制的延伸，即八进制和十六进制，可以适用于unsigned变量输出

### 第七题

若整型变量a、b、c、d中的值依次为：1、4、3、2。则条件表达式a<b?a:c<d?c:d的值（）

A

1

B

2

C

3

D

4

解答：

a<b?a:(c<d?c:d)    

### 第八题

定义:int *const ptr;下面哪种说法是正确的()

A

ptr不可修改，*ptr可修改

B

ptr不可修改，*ptr不可修改

C

ptr可修改，*ptr不可修改

D

ptr可修改，*ptr可修改

解答：

考察const的作用，不需要死记硬背，没那么复杂。

const 的作用就是封锁它后面的东西，即后面的不可改变。

对于`int *const ptr`;  没有const关键字时，为`int* ptr` 此时ptr是指向int的指针。加上const后，const修饰并封锁ptr  。即ptr的指向不可改变。

同理 `int const* ptr`(等同 `const int *ptr`)  。const修饰 *  解引用  ，即指针指向的内容不可改变。

## 第三十四天

### 第一题

在C语言中，char型数据在内存中的存储形式是（ ）

A

补码

B

反码

C

原码

D

ASCII码

解答：

C语言中，负数在内存中存储的是补码形式 

 

  正数在内存中以原码形式存储 

 

  浮点数是采用某种规则转换后存储 

 

  char型是直接将其对应的ASCII码存储

### 第二题

已知const char * node="ABC"；下列语句合法的是___.

A

node[2] = 'k';

B

*node[2]='k';

C

*node = "xyz";

D

node="xyz";

解答：

D。 const char * node="ABC"。node是一个指针，它指向的内容是const char 类型。node可以指向任何标示符，但它指向的内容是不能被改变的，但是A、B、C三项均改变了它指向的内容。

### 第三题

C库函数中malloc依赖下面哪个系统调用增长堆空间（）

A

open

B

ioctl

C

sbrk

D

write

解答：

```c
open：打开和创建文件；
ioctl：设备输入输出操作的系统调用；
sbrk：实现虚拟内存到内存的映射；
write:将数据写入一个打开的文件。
```

### 第四题

test.c文件中包括如下语句：

```c
#define INT_PTR int*
typedef int*int_ptr;
INT_PTR a,b;
int_ptr c,d;
```

文件中定义的四个变量，哪个变量不是指针类型？

A

a

B

b

C

c

D

d

E

都是指针

F

都不是指针

解答：

B #define为宏定义指令 int*为宏体是整型指针，INT_PTR为宏名；经过预处理，进行宏替换，INT_PTR a,b;替换为int* a,b;故a是整型指针而b是整型。 typedef作用是给已存在的数据类型引入一个别名，语法 typedef 已有类型名 类型别名，所以 int_ptr 是int*整型指针类型的别名。

### 第五题

字符串"//＾▽＾//\n"的长度是（）

A

6

B

7

C

8

D

9

解答：

/            1  /            2  ^        3  △       4  ^        5  /      6  /       7  \n      8 注意：转义字符是反斜杠\\，不是// （个人意见） 

### 第六题

程序最后输出什么？（  ）

```c
#define Mul(x,y) ++x*++y
  
void main()
{
    int a = 1;
    int b = 2;
    int c = 3;
  
    printf(“%d”,Mul(a+b,b+c));
}
```

A

14

B

24

C

48

D

18

解答：

Mul(a+b,b+c)经过宏替换变成++a+b*++b+c，需要注意宏替换的原则，是不会凭空加括号的。另外++优先级大于*，因此会先++a 和++b，然后a=2,b=3进行a+b*b+c=2+3*3+3=14 

### 第七题

表达式0x13&0x17的值是（ ）

A

0x17

B

0x13

C

0xf8

D

0xec

解答：

0x开头的数为16进制数，&为“按位与”。


  0x13和0x17用二进制数表示为00010011和00010111，相应的二进制位都为1，结果才为1. 

  计算如下： 

​     00010011       00010111       00010011   

  此时结果为0x13。 

### 第八题

32位系统中，如下程序执行的结果是（）

```c
#include <stdio.h>
int main() {
  char str[] = {"hello world"};
  printf("%s",str);
  return 0;
}
```

A

"hello"

B

NULL

C

"hello world"

D

"h"

E

str的首地址

解答：

在数组名做为函数参数和用于表达式中的时候,数组名就退化成了指针,这个退化是完全意义上的,即数组名实际上就是成了一个指针变量,可以完全用解析指针的方法来解析数组名  

答案为c

## 关于C语言中str转换为int以及强制类型转换

数字字符不能直接变成本身的数字，这里有将字符串转换为整数的几种方法。

### 1. **`atoi` 函数** (字符串到整数)

- **原型**：`int atoi(const char *str);`
- **功能**：将字符串 `str` 转换为整数。它忽略前导空格，直到遇到第一个非数字字符为止（包括符号）。
- **优点**：简洁直接，适合快速转换。
- **缺点**：如果字符串包含无效数字或格式错误，它将返回 0，不提供错误处理机制。

```c
char str[] = "123";
int num = atoi(str);  // num = 123
char str[] = "abc";  
int num = atoi(str);  // num = 0
```

**注意**：`atoi` 只适用于输入格式简单的场景，无法检测转换过程中是否发生错误。

------

### 2. **`strtol` 函数** (更安全的转换)

- **原型**：`long int strtol(const char *str, char **endptr, int base);`
- **功能**：将字符串 `str` 转换为 `long int` 类型（支持指定进制）。它比 `atoi` 更加灵活和安全，能够提供错误检查，并支持不同的进制（如二进制、十六进制等）。
- **优点**：能够检测并返回转换过程中遇到的错误（通过 `endptr`），可以指定进制。
- **缺点**：返回值是 `long int` 类型，需要手动转换为 `int`（如果超出 `int` 范围）。

```c
char str[] = "123";
char *endptr;
long num = strtol(str, &endptr, 10);  // num = 123, endptr 指向 ' '（空格）的位置
if (*endptr != '\0') {
    // 错误处理：str中包含非数字字符
}
```

**注意**：

- `endptr` 指向第一个不能转换的字符，这使得你可以检测字符串中是否包含额外的无效字符。
- `strtol` 返回的是 `long int`，如果输入数字超出了 `int` 范围，转换的结果可能不符合预期。

------

### 3. **`strtoi` 函数**（部分平台支持，类似于 `strtol`）

- **原型**：`int strtoi(const char *str, char **endptr, int base);`
- **功能**：与 `strtol` 类似，只不过它返回的就是 `int` 类型。它在一些平台上是可用的，但不一定适用于所有编译器。

```c
char str[] = "123";
char *endptr;
int num = strtoi(str, &endptr, 10);  // num = 123
```

------

### 4. **`sscanf` 函数** (字符串到整数)

- **原型**：`int sscanf(const char *str, const char *format, ...);`
- **功能**：`sscanf` 可以根据指定的格式从字符串中提取整数。它允许更灵活的格式化输入，能够处理更多复杂的情况（如跳过前导空格、处理不同类型等）。
- **优点**：支持多种格式转换，灵活且易于控制输入的解析过程。
- **缺点**：如果使用不当，可能会导致格式解析错误。

```c
char str[] = "123 abc";
int num;
sscanf(str, "%d", &num);  // num = 123
```

------

### 5. **`strtod`/`strtof` 函数** (用于浮点数转换，但可以与整数结合)

- **原型**：`double strtod(const char *str, char **endptr);`（类似 `strtof`）
- **功能**：将字符串转换为浮点数（`double`）。如果字符串包含数字和小数部分，可以使用 `strtod` 将字符串转换为浮点数。虽然主要用于浮点数，但也可以从中提取整数部分。
- **优点**：支持浮点数，适用于包含浮点数的字符串。
- **缺点**：它返回的是浮点类型，需要手动提取整数部分。

```c
char str[] = "123.45";
char *endptr;
double num = strtod(str, &endptr);  // num = 123.45
int integer_part = (int)num;  // integer_part = 123
```

