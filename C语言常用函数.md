# C语言常用函数

## 1.realloc

`realloc` 是 C 标准库中的一个内存管理函数，用于调整已分配内存块的大小。它可以扩大或缩小现有内存块的大小，而不需要重新分配一个新的内存块并手动复制数据。

`realloc` 函数原型

```c
void* realloc(void* ptr, size_t new_size);
```

### 参数说明

- **`ptr`**：指向之前通过 `malloc`、`calloc` 或 `realloc` 分配的内存块的指针。如果 `ptr` 为 `NULL`，`realloc` 的行为类似于 `malloc`，分配一个新的内存块。
- **`new_size`**：新的大小（以字节为单位），指定要将内存块调整到的大小。

### 返回值

- `realloc` 返回一个指向新内存块的指针。如果内存分配失败，返回 `NULL`，而原来的内存块不会被释放。

### 使用场景

1. **扩大内存**：当数组或结构需要存储更多数据时，可以使用 `realloc` 扩大内存，而不必创建一个新数组并手动复制数据。
2. **缩小内存**：减少不再需要的内存块大小，释放未使用的内存。

### 注意事项

- 如果 `realloc` 分配失败，它返回 `NULL`，而原来的内存块仍然有效。因此，在使用 `realloc` 后应检查返回值，以确保分配成功。
- 如果需要缩小内存块的大小，`realloc` 将直接调整内存块大小，而不会影响原有数据。
- 若 `ptr` 为 `NULL`，则 `realloc` 等效于 `malloc`，分配一个新的内存块。
- 若 `new_size` 为 0，`realloc` 的行为类似于 `free`，会释放原有的内存块。

## 2.qsort

`qsort` 是 C 标准库中的一个通用排序函数，用于对数组中的元素进行排序。它支持对任何数据类型（整数、浮点数、结构体等）进行排序，只要提供合适的比较函数。

`qsort` 函数原型

```c
void qsort(void* base, size_t nitems, size_t size, int (*compar)(const void*, const void*));
```

### 参数说明

- **`base`**：指向待排序数组的指针（即数组的首地址）。
- **`nitems`**：数组中元素的个数。
- **`size`**：每个元素的大小（以字节为单位）。
- **`compar`**：比较函数指针，用于定义元素的排序规则。

### 比较函数

`qsort` 需要一个比较函数来决定排序顺序。比较函数必须接收两个指针作为参数，指向待比较的两个元素。它根据以下规则返回一个整数值：

- **负值**：如果第一个元素小于第二个元素（第一个元素应排在前面）。
- **零**：如果两个元素相等。
- **正值**：如果第一个元素大于第二个元素（第二个元素应排在前面）。

例如，对于整数数组的升序排序，比较函数可以写成如下：

```c
int compare(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}
```

在这个函数中，我们将 `void*` 类型的指针转换为 `int*`，然后解引用以进行整数比较。

## 3.strdup

`strdup` 是 C 标准库中用于复制字符串的函数。它会为新的字符串动态分配内存，并将原字符串的内容复制到新分配的内存中。这个函数在需要复制字符串到新位置并确保有独立内存时非常有用。

`strdup` 函数原型

```c
char* strdup(const char* s);
```

### 参数说明

- **`s`**：指向要复制的源字符串的指针。

### 返回值

- 返回指向新分配的字符串的指针，新字符串包含和 `s` 相同的内容。
- 如果内存分配失败，返回 `NULL`。

### 内存管理

- `strdup` 动态分配的内存需要在不再使用时通过 `free` 函数来释放，以避免内存泄漏。

### `strdup` 的实际用途

- **深拷贝字符串**：在需要创建字符串副本而不是共享内存时，`strdup` 是一个便捷的选择。
- **避免字符串数据丢失**：当一个函数需要返回一个字符串副本，但又不能确定接收者的内存分配时，`strdup` 可以帮助分配一个新的副本。

### 注意事项

- **`strdup` 不是 C89 标准库函数**，在一些较旧的 C 标准中（如 C89），`strdup` 不是标准的一部分。在这些环境中可能需要使用替代方法。
- **`strdup` 需要 `free`**：使用 `strdup` 后一定要记得使用 `free` 来释放内存，否则会导致内存泄漏。

## 4.strndup

`strndup` 是 C 库中用于复制字符串的函数，它从源字符串中复制指定数量的字符，并为新字符串动态分配内存。在指定长度不超过源字符串长度的情况下，它会将指定数量的字符复制到新字符串中，并自动添加 `'\0'` 作为字符串的结束符。

`strndup` 函数原型

```c
char *strndup(const char *s, size_t n);
```

### 参数说明

- **`s`**：指向源字符串的指针。
- **`n`**：要复制的字符数（最多复制 `n` 个字符）。

### 返回值

- `strndup` 返回指向新字符串的指针，该字符串包含从源字符串 `s` 复制的 `n` 个字符。
- 如果 `n` 大于源字符串的长度，则只复制到源字符串的末尾，并添加终止符 `\0`。
- 如果内存分配失败，则返回 `NULL`。

> **注意**：`strndup` 动态分配的内存需要在使用完后使用 `free` 释放，以避免内存泄漏。

### `strndup` 的实际用途

- **部分字符串复制**：如果只想复制字符串的一部分，可以使用 `strndup` 直接指定要复制的字符数。
- **深拷贝字符串**：当你只需要源字符串的一部分而不影响原字符串时，`strndup` 是个非常方便的工具。

## 5.calloc

`calloc` 是 C 语言中的一个内存分配函数，它用于动态分配内存块并初始化分配的内存为零。与 `malloc` 函数相比，`calloc` 会自动将分配的内存空间初始化为全零，这在某些场景下很有用。以下是 `calloc` 函数的详细介绍：

### 函数原型

```c
void *calloc(size_t num, size_t size);
```

- **`num`**：要分配的内存块的数量。
- **`size`**：每个内存块的大小（单位为字节）。
- 返回值为指向已分配内存的指针，如果分配失败返回 `NULL`。

### 功能

- `calloc` 函数用于分配一个包含 **`num` 个元素**，每个元素的大小为 **`size` 字节** 的连续内存块。
- 与 `malloc` 不同的是，`calloc` 会将分配的每个字节都初始化为零（即所有位都置为 `0`）。

### 详细说明

1. **用法示例**

```c
#include <stdlib.h>

int main() {
    int n = 5;

    // 分配 5 个整数类型的内存空间
    int* arr = (int*) calloc(n, sizeof(int));
    if (arr == NULL) {
        // 分配失败处理
        return 1;
    }

    // 使用分配的内存
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);  // 所有值将被初始化为 0
    }

    // 释放内存
    free(arr);
    return 0;
}
```

在上面的代码中，`calloc` 被用于分配 `n` 个整数类型的内存空间（每个为 `sizeof(int)` 字节），并将分配的内存初始化为零。

**返回值**

- `calloc` 返回一个指向已分配内存的指针，其类型为 `void*`。
- 你通常需要将返回的指针类型转换为适合的指针类型，例如 `(int*)` 或 `(float*)`。
- 如果内存分配失败（例如由于内存不足），`calloc` 会返回 `NULL`，所以你应该检查返回值是否为 `NULL`。

**初始化为零**

- calloc与 malloc最大的区别在于初始化。
  - `malloc` 只分配内存，但不会对分配的内存进行初始化。因此，使用 `malloc` 后，内存中的数据是未定义的（随机数据）。
  - `calloc` 会将分配的内存初始化为 **零**，即每一个字节都是 `0`，所以对于整数类型的数据，会初始化为 `0`，对于指针类型的数据，初始化为 `NULL`。

## 6.memset

`memset` 是 C 标准库中的一个函数，常用于初始化数组或内存块，将内存块中的所有字节设置为某个特定的值。`memset` 属于 `string.h` 头文件的一部分，下面是它的详细介绍和用法。

### 函数原型

```c
void *memset(void *ptr, int value, size_t num);
```

### 参数说明

- **`ptr`**：指向要设置的内存块的起始地址。
- **`value`**：要设置的值（以 `int` 形式传递，但会转换为 `unsigned char`，即 0-255 的范围）。
- **`num`**：要设置的字节数（`size_t` 类型）。

### 返回值

- 返回指向目标内存块的指针 `ptr`。

### 功能

- `memset` 函数将内存块 `ptr` 的前 `num` 个字节设置为 `value` 的值。
- 由于 `value` 被转换为 `unsigned char` 类型，所以它只能取 0-255 的范围。

### 典型用法

`memset` 常用于将内存块初始化为特定值。例如，可以将数组或结构体的所有字节初始化为 `0` 或 `-1`，确保数据干净而不会出现未初始化的随机值。

### 示例

```c
#include <stdio.h>
#include <string.h>

int main() {
    // 定义一个大小为 10 的整型数组
    int arr[10];

    // 使用 memset 将数组所有元素初始化为 0
    memset(arr, 0, sizeof(arr));

    // 打印数组
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);  // 输出：0 0 0 0 0 0 0 0 0 0
    }
    printf("\n");

    // 将数组所有元素初始化为 -1
    memset(arr, -1, sizeof(arr));

    // 打印数组
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);  // 由于 -1 转为 unsigned char 后为 255，int 类型解释为 -1
    }
    printf("\n");

    return 0;
}
```