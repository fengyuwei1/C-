# C++算法和数据结构

## 1.前缀和

前缀和（Prefix Sum）是一种高效计算数组区间和的算法。它的基本思想是通过预处理数组，快速计算任意区间的和。以下是实现前缀和的步骤和示例代码。

前缀和（Prefix Sum）是一种高效计算数组区间和的算法。它的基本思想是通过预处理数组，快速计算任意区间的和。以下是实现前缀和的步骤和示例代码。

**算法步骤**

1. **构建前缀和数组**：

   - 创建一个新的数组 `prefix_sum`，其中 `prefix_sum[i]` 表示原数组从开始到第 `i` 个元素的和。
   - 计算方法为：`prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]`（假设原数组的索引从1开始，`prefix_sum[0]`初始化为0）。

2. **查询区间和**：

   - 对于任意区间 

     ```
     [l, r]
     ```

     ，区间和可以通过前缀和数组快速计算：

     - `sum(l, r) = prefix_sum[r] - prefix_sum[l - 1]`

1. **构建前缀和数组**：

   - 创建一个新的数组 `prefix_sum`，其中 `prefix_sum[i]` 表示原数组从开始到第 `i` 个元素的和。
   - 计算方法为：`prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]`（假设原数组的索引从1开始，`prefix_sum[0]`初始化为0）。

2. **查询区间和**：

   - 对于任意区间 

     ```
     [l, r]
     ```

     ，区间和可以通过前缀和数组快速计算：

     - `sum(l, r) = prefix_sum[r] - prefix_sum[l - 1]`

前缀和算法通常用于以下几个方面：

1. **数组和查询**：
   - 在处理数组时，需要频繁查询某个子区间的和。前缀和能将这些查询的时间复杂度降到 O(1)，极大提高效率。
2. **动态规划**：
   - 在动态规划问题中，前缀和常用于减少计算复杂度，避免重复计算。尤其是在求解区间和相关的动态规划问题时，前缀和能够加速状态转移。

### 1.1 一维前缀和

**题目描述**

对于一个有 n*n* 个元素的数组进行 k*k* 次区间求和。

**输入格式**

第一行：一个正整数 n； 第二行：n个正整数，表示数组中的 n 个元素，每个整数不超过 10000，数值之间用一个空格分隔； 第三行：一个正整数 k，表示进行 k 次区间求和； 接下来 k 行：每行两个整数 l 和 r，表示计算第 l 个数组元素到第 r 个数组元素的和，包括第 l 个和第 r个。

**输出格式**

共*k*行，每行对应一次求和的结果。

**解答：**

```c++
#include <iostream>
using namespace std;
const int N = 2e5;
int main() {
   int arr[N];
   int pervsum[N] = {0};
   int n;
   cin >> n;
   for(int i = 1;i <= n;i++)
   {
    cin >> arr[i];
    pervsum[i] = pervsum[i-1] + arr[i];
   }
   int k;
   cin >> k;
   while(k--)
    {
        int l,r;
        cin >> l >> r;
        int sum = pervsum[r] - pervsum[l-1];
        printf("%d\n",sum);
    }
   return 0;
}
```

### 1.2 dash与机器人

#### 题目描述

dash学长发明了一个机器人在数轴上运动，现在有 n*n* 条移动指令需要机器人执行，分别为 a1,a2,…,an。+ 代表正向移动，−代表反向移动，每条移动指令的规则如下：

- 移动 a1 的距离。

- 移动 a1 的距离，再移动 a2的距离。

  ……

- 移动 a1 的距离，再移动 a2的距离，……，移动 an的距离。

请问最远能移动到数轴的正向位置。

#### 输入格式

第一行为一个正整数 n*n*，代表有 n*n* 条指令 。‘

第二行为 n*n* 个正整数 a1,a2,…,an*a*1,*a*2,…,*a**n* ，代表有 n*n* 条指令。

#### 输出格式

输出一行，一个整数表示答案。

#### 解释 #1

输入数据2

```c++
4
-1 2 1 -3
```

输出数据2

```c++
4
```

#### 解释 #2

- 第一步移动到 −1−1 的位置。
- 第二步先移动到 −2−2 的位置，再移动到 00 的位置。
- 第三步先移动到 −1−1 的位置，再移动到 11 的位置，最后移动到 22 的位置。
- 第四步先移动到 11 的位置，再移动到 33 的位置，再移动到 44 的位置，最后移动到 11 的位置。

解答：

```c++
```

