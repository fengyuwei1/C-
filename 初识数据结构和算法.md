# 初识数据结构和算法

## 1.线性结构

### 1.1线性表

线性表（linear list）是n个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串...
线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理上存储时，通常以数组和链式结构的形式存储。

### 1.2 顺序表

顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成数据的增删查改。

1. 顺序表一般可以分为：

**（1）静态顺序表：使用定长数组存储元素**

**（2）动态顺序表：使用动态开辟的数组存储**

**注意：**

静态顺序表只适用于确定知道需要存多少数据的场景。静态顺序表的定长数组导致N定大了，空间开多了浪费，开少了不够用。所以现实中基本都是使用动态顺序表，根据需要动态的分配空间大小，所以下面我们实现动态顺序表。

### 1.3 顺序表的实现

```c
#define  _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
typedef int E;
struct list {
	E * array; //实现顺序表的底层数组
	int capacity; //表示底层数组的容量
	int size; //表中的元素数量
};
typedef struct list* ArrayList;
//初始化顺序表
_Bool initlist(ArrayList node)
{
	node->capacity = 10;
	node->array = malloc(sizeof(E) * node->capacity);
	if (node->array == NULL)return 0;//判断是否为空指针
	node->size = 0;
	return 1;
}
//顺序表的插入
_Bool insertlist(ArrayList list, E element, int index)
{
	if (index < 1 || index > list->size + 1)return 0;
	if (list->size == list->capacity) //如果size已经到达最大的容量了，肯定是插不进了，那么此时就需要扩容了
	{
		int newcapacity = list->capacity + (list->capacity << 1); //我们先计算一下新的容量大小，这里我取1.5倍原长度，当然你们也可以想扩多少扩多少
		E* newArray = realloc(list->size, newcapacity * sizeof(E)); //这里我们使用新的函数realloc重新申请更大的内存空间
		if (newArray == NULL)return 0;
		list->array = newArray;
		list->capacity = newcapacity;
	}
	for (int i = list->size; i > index - 1; --i)
	{
		list->array[i] = list->array[i - 1];
	}
	list->array[index - 1] = element;
	list->size++;
}
//顺序表的删除
_Bool deletelist(ArrayList list, int index)
{
	if (index < 1 || index > list->size)return 0;
	for (int i = index - 1; i < list->size - 1; ++i)
	{
		list->array[i] = list->array[i + 1];
	}
	list->size--;
	return 1;
}
int sizeList(ArrayList list) {
	return list->size;   //直接返回size就完事
}
E* getList(ArrayList list, int index) {
	if (index < 1 || index > list->size) return NULL;   //如果超出范围就返回NULL
	return &list->array[index - 1];
}
int findList(ArrayList list, E element) {
	for (int i = 0; i < list->size; ++i) {   //一直遍历，如果找到那就返回位序
		if (list->array[i] == element) return i + 1;
	}
	return -1;  //如果遍历完了都没找到，那么就返回-1
}
void printList(ArrayList list) {   //编写一个函数用于打印表当前的数据
	for (int i = 0; i < list->size; ++i)   //表里面每个元素都拿出来打印一次
		printf("%d ", list->array[i]);
	printf("\n");
}
```

### 1.4 单链表

链表不同于顺序表，顺序表底层采用数组作为存储容器，需要分配一块连续且完整的内存空间进行使用，而链表则不需要，它通过一个指针来连接各个分散的结点，形成了一个链状的结构，每个结点存放一个元素，以及一个指向下一个结点的指针，通过这样一个一个相连，最后形成了链表。它不需要申请连续的空间，只需要按照顺序连接即可，虽然物理上可能不相邻，但是在逻辑上依然是每个元素相邻存放的，这样的结构叫做链表（单链表）。
代码实现：

```c
#define  _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
typedef int E;
struct listnode
{
	E element;
	struct listnode* next;
};
typedef struct listnode* node;
//链表初始化
void initlist(node head)
{
	head->next = NULL;
}
_Bool insertlist(node head,E element,int index)
{
	if (index < 1)return 0;
	while (--index)
	{
		head = head->next;
		if (head == NULL)return 0;
	}
	node Node = malloc(sizeof(struct listnode);
	if (Node == NULL)return 0;
	Node->element = element;
	Node->next = head->next;
	head->next = Node;
	return 1;
}
//打印链表
void printlist(node head)
{
	while (head->next != NULL)
	{
		head = head->next;
		printf("%d\n", head->element);
	}
}
//删除节点
_Bool deletelist(node head,int index)
{
	if (index < 0)return 0;
	while (index--)
	{
		head = head->next;
		if (head == NULL)return 0;
	}
	if (head->next == NULL)return 0;
	node tmp = head->next;
	head->next = head->next->next;
	free(tmp);
	return 1;
}
E* getList(node head, int index) {
	if (index < 1) return NULL;   //如果小于0那肯定不合法，返回NULL
	do {
		head = head->next;  //因为不算头结点，所以使用do-while语句
		if (head == NULL) return NULL;  //如果已经超出长度那肯定也不行
	} while (--index);  //到达index就结束
	return &head->element;
}
int findList(node head, E element) {
	head = head->next;    //先走到第一个结点
	int i = 1;   //计数器
	while (head) {
		if (head->element == element) return i;   //如果找到，那么就返回i
		head = head->next;   //没找到就继续向后看
		i++;   //i记住要自增
	}
	return -1;   //都已经走到链表尾部了，那么就确实没找到了，返回-1
}
int sizeList(node head) {
	int i = 0;  //从0开始
	while (head->next) {   //如果下一个为NULL那就停止
		head = head->next;
		i++;   //每向后找一个就+1
	}
	return i;
}
```

### 1.5 双向链表

前面我们介绍了单链表，通过这样的链式存储，我们不用再像顺序表那样一次性申请一段连续的空间，而是只需要单独为结点申请内存空间，同时在插入和删除的速度上也比顺序表轻松。不过有一个问题就是，如果我们想要操作某一个结点，比如删除或是插入，那么由于单链表的性质，我们只能先去找到它的前驱结点，才能进行。

为了解决这种查找前驱结点非常麻烦的问题，我们可以让结点不仅保存指向后续结点的指针，同时也保存指向前驱结点的指针
这样我们无论在哪个结点，都能够快速找到对应的前驱结点，就很方便了，这样的链表我们成为双向链表（双链表）

代码实现:

```c
#define  _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
struct listnode
{
	int element;
	struct listnode* next;
	struct listnode* prev;
};
void initlist(struct listnode* node)
{
	node->next = node->prev = NULL;
}
_Bool insertlist(struct listnode* node, int index, int element)
{
	if (index < 1)return 0;
	while (--index)
	{
		node = node->next;
		if (node == NULL)return 0;
	}
	struct listnode* newnode = malloc(sizeof(struct listnode));
	if (newnode == NULL)return 0;
	newnode->element = element;
	newnode->next = node->next;
	node->next = newnode;
	newnode->prev = node;
	if (newnode->next != NULL)
	{
		newnode->next->prev = newnode;
	}
	return 1;
}
_Bool deletelist(struct listnode* node, int index)
{
	if (index < 1)return 0;
	while (--index)
	{
		node = node->next;
		if (node == NULL)return 0;
	}
	struct listnode* tmp = node->next;
	node->next = node->next->next;
	if (node->next != 0)
		node->next->prev = node;
	free(tmp);
	return 1;
}
int main() {
	struct listnode head;
	initlist(&head);

	// 插入5个元素
	for (int i = 1; i <= 5; ++i)
		insertlist(&head, i, i * 100);

	struct listnode* node = &head;
	struct listnode* tmp = &head;
	deletelist(&head, 1);
	// 正向遍历链表
	printf("正向遍历:\n");
	node = node->next;  // 跳过头节点
	while (node != NULL) {
		printf("%d -> ", node->element);
		if (node->next == NULL) break;  // 避免越界
		node = node->next;
	}
	printf("NULL\n");

	// 反向遍历链表
	printf("反向遍历:\n");
	while (node != NULL) {
		printf("%d -> ", node->element);
		if (node->prev == tmp) break;  // 避免越界
		node = node->prev;
	}
	printf("NULL\n");

	return 0;
}

```

### 1.6 循环链表

循环链表（Circular Linked List）是一种特殊的链表结构，其尾节点指向头节点，从而形成一个环状的链表。循环链表可以是单向的，也可以是双向的。与普通链表不同，循环链表没有明确的终点，遍历链表时需要特别注意，以避免陷入无限循环。

代码实现：

```c
#include <stdio.h>
#include <stdlib.h>

struct listnode {
    int element;
    struct listnode* next;
};

// 初始化链表（单向循环）
void initlist(struct listnode* node) {
    node->next = node;  // 自己指向自己，形成循环
}

// 插入节点到指定位置
_Bool insertlist(struct listnode* node, int index, int element) {
    if (index < 1) return 0;

    struct listnode* start = node;  // 保存起始位置
    while (--index) {
        node = node->next;
        if (node == start) return 0;  // 如果循环到头节点，说明索引无效
    }

    struct listnode* newnode = malloc(sizeof(struct listnode));
    if (newnode == NULL) return 0;

    newnode->element = element;
    newnode->next = node->next;
    node->next = newnode;

    return 1;
}

// 删除指定位置的节点
_Bool deletelist(struct listnode* node, int index) {
    if (index < 1) return 0;

    struct listnode* start = node;  // 保存起始位置
    while (--index) {
        node = node->next;
        if (node->next == start) return 0;  // 如果循环到头节点，说明索引无效
    }

    struct listnode* tmp = node->next;
    node->next = tmp->next;
    free(tmp);

    return 1;
}

// 遍历循环链表
void printlist(struct listnode* node) {
    struct listnode* start = node;
    node = node->next;  // 跳过头节点
    printf("链表内容: ");
    do {
        printf("%d -> ", node->element);
        node = node->next;
    } while (node != start);
    printf("(回到头节点)\n");
}

int main() {
    struct listnode head;
    initlist(&head);

    // 插入5个元素
    for (int i = 1; i <= 5; ++i)
        insertlist(&head, i, i * 100);

    // 正向遍历链表
    printlist(&head);

    // 删除第一个元素
    deletelist(&head, 1);

    // 正向遍历链表
    printlist(&head);

    return 0;
}
```

### 1.7 实战遇到的双指针算法

双指针算法是一种非常常用的算法策略，通常用于遍历列表或数组，在不同情况下控制两个指针来完成某些操作。常见的双指针问题包括快慢指针、左右指针等。下面以两个经典的双指针问题为例，展示如何用 C 语言实现双指针算法。

实例：

### 合并两个有序数组

在这个问题中，给定两个升序数组，要求合并成一个新的升序数组。双指针策略可以非常有效地解决这个问题。两个指针分别指向两个数组的当前元素，比较两个元素并将较小的一个插入到结果数组中，直到其中一个数组遍历完毕。

```c
#include <stdio.h>
#include <stdlib.h>

// 合并两个有序数组
void merge(int* nums1, int m, int* nums2, int n, int* result) {
    int i = 0, j = 0, k = 0;

    // 使用双指针进行合并
    while (i < m && j < n) {
        if (nums1[i] <= nums2[j]) {
            result[k++] = nums1[i++];
        } else {
            result[k++] = nums2[j++];
        }
    }

    // 将剩余元素添加到结果数组中
    while (i < m) {
        result[k++] = nums1[i++];
    }
    while (j < n) {
        result[k++] = nums2[j++];
    }
}

int main() {
    int nums1[] = {1, 3, 5, 7};
    int nums2[] = {2, 4, 6, 8};
    int m = 4;
    int n = 4;
    
    // 创建一个结果数组
    int* result = (int*)malloc((m + n) * sizeof(int));
    
    // 调用合并函数
    merge(nums1, m, nums2, n, result);

    // 打印结果数组
    for (int i = 0; i < m + n; i++) {
        printf("%d ", result[i]);
    }

    free(result);  // 释放内存
    return 0;
}
```



### 链表实战

#### 1.两数相加

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

 

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

解答：

```c
struct ListNode* create(int val)
{
    struct ListNode* newnode = (struct ListNode*)malloc(sizeof(struct ListNode));
    if(newnode == NULL)return 0;
    newnode->val = val;
    newnode->next = NULL;
    return newnode;
}
struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {
    struct ListNode* head = create(0);
    struct ListNode* current = head;
    int curry = 0;
    while(l1 != NULL || l2 != NULL)
    {
        int val1 = (l1 != NULL)?l1->val:0;
        int val2 = (l2 != NULL)?l2->val:0;
        int sum = val1+val2+curry;
        curry = sum / 10;
        current->next = create(sum % 10);
        current = current->next;
        if(l1 != NULL)l1 = l1->next;
        if(l2 != NULL)l2 = l2->next;
    }    
    if(curry > 0)
    {
        current->next = create(curry);
    }
    return head->next;
}
```

#### 2.删除链表的倒数第N个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

 

**示例 1：**

```c
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```c
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```c
输入：head = [1,2], n = 1
输出：[1]
```

 

**提示：**

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

解答：

```c
struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {
    struct ListNode* node = malloc(sizeof(struct ListNode));
    node->val = 0;
    node->next = head;
    struct ListNode* first = node;
    struct ListNode* finally = node;
    for(int i = 0;i < n;i++)
    {
        first = first->next;
    } 
    while(first->next != NULL)
    {
        first = first->next;
        finally = finally->next;
    }
    finally->next = finally->next->next;
    return node->next;
}
```



#### 3.合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

**示例 1：**

```c
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```c
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```c
输入：l1 = [], l2 = [0]
输出：[0]
```

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

解答：

```c
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    struct ListNode node;
    struct ListNode* newnode = &node;
    newnode->next = NULL;
    while(list1 != NULL && list2 != NULL)
    {
        if(list1->val <= list2->val)
        {
            newnode->next = list1;
            list1 = list1->next;
        }
        else
        {
            newnode->next = list2;
            list2 = list2->next;
        }
        newnode = newnode->next;
    }
    if(list1 != NULL)
    {
        newnode->next = list1;
    }
    else
    {
        newnode->next = list2;
    }
    return node.next;
}
```

#### 4.删除排序链表中的重复元素

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/04/list1.jpg)

```
输入：head = [1,1,2]
输出：[1,2]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/04/list2.jpg)

```
输入：head = [1,1,2,3,3]
输出：[1,2,3]
```

 

**提示：**

- 链表中节点数目在范围 `[0, 300]` 内
- `-100 <= Node.val <= 100`
- 题目数据保证链表已经按升序 **排列**

解答：

```c
struct ListNode* deleteDuplicates(struct ListNode* head) {
    struct ListNode* node = head;
    if(head == NULL)
    return NULL;
    while(head->next != NULL)
    {
        if(head->val == head->next->val)
        {
            struct ListNode* tmp = head->next;
            head->next = head->next->next;
            free(tmp);
        }
        else{
            head = head->next;
        }
    }
    return node;
}
```

#### 5.两两交换链表中的节点

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 1：**

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

解答：

```c
struct ListNode* swapPairs(struct ListNode* head) {
    struct ListNode node;
    node.next = head;
    struct ListNode* tmp = &node;
    while(tmp->next != NULL && tmp->next->next != NULL)
    {
        struct ListNode* first = tmp->next;
        struct ListNode* second = tmp->next->next;
        tmp->next = second;
        first->next = second->next;
        second->next = first;
        tmp = first;
    }
    return node.next;
}
```

#### 6.旋转链表

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)

```
输入：head = [0,1,2], k = 4
输出：[2,0,1]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 500]` 内
- `-100 <= Node.val <= 100`
- `0 <= k <= 2 * 109`

解答：

```c
struct ListNode* rotateRight(struct ListNode* head, int k) {
    if (k == 0 || head == NULL || head->next == NULL) {
        return head;
    }
    int n = 1;
    struct ListNode* iter = head;
    while (iter->next != NULL) {
        iter = iter->next;
        n++;
    }
    int add = n - k % n;
    if (add == n) {
        return head;
    }
    iter->next = head;
    while (add--) {
        iter = iter->next;
    }
    struct ListNode* ret = iter->next;
    iter->next = NULL;
    return ret;
}
```

#### 7.删除排序链表中的重复元素

给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)

```
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)

```
输入：head = [1,1,1,2,3]
输出：[2,3]
```

 

**提示：**

- 链表中节点数目在范围 `[0, 300]` 内
- `-100 <= Node.val <= 100`
- 题目数据保证链表已经按升序 **排列**

解答：

```c
struct ListNode* deleteDuplicates(struct ListNode* head) {
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummy->val = 0;
    dummy->next = head;
    
    struct ListNode* prev = dummy; 
    struct ListNode* current = head;
    
    while (current != NULL) {
        if (current->next != NULL && current->val == current->next->val) {
            while (current->next != NULL && current->val == current->next->val) {
                current = current->next;
            }
            prev->next = current->next;
        } else {
            prev = prev->next;
        }
        current = current->next;
    }
    
    struct ListNode* newHead = dummy->next;
    free(dummy);
    return newHead;
}
```

#### 8.分割链表

给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)

```
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```

**示例 2：**

```
输入：head = [2,1], x = 2
输出：[1,2]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 200]` 内
- `-100 <= Node.val <= 100`
- `-200 <= x <= 200`

解答：

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* partition(struct ListNode* head, int x) {
    struct ListNode* first = malloc(sizeof(struct ListNode));
    struct ListNode* finally = malloc(sizeof(struct ListNode));
    first->val = 0;
    finally->val = 0;
    first->next = NULL;
    finally->next = NULL;
    struct ListNode* firsthead = first;
    struct ListNode* finallyhead = finally;
    while(head != NULL)
    {
        if(head->val < x)
        {
            first->next = head;
            first = first->next;
        }
        else
        {
            finally->next = head;
            finally = finally->next;
        }
        head = head->next;
    }
    finally->next = NULL;
    struct ListNode* newnode = malloc(sizeof(struct ListNode));
    newnode->val = 0;
    newnode->next = NULL;
    first->next = finallyhead->next;
    newnode->next = firsthead->next;
    return newnode->next;
}
```

#### 9.回文链表

给你一个单链表的头节点 `head` ，请你判断该链表是否为

回文链表

。如果是，返回 `true` ；否则，返回 `false` 。



 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)

```
输入：head = [1,2,2,1]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg)

```
输入：head = [1,2]
输出：false
```

 

**提示：**

- 链表中节点数目在范围`[1, 105]` 内
- `0 <= Node.val <= 9`

 解答：

```c
struct ListNode* copy(struct ListNode* head) {  
    if (head == NULL) return NULL;  
    struct ListNode* node = malloc(sizeof(struct ListNode));  
    struct ListNode* cur = node;  
    struct ListNode* temp = head;  
    while (temp != NULL) {  
        cur->val = temp->val;  
        if (temp->next != NULL) {  
            cur->next = malloc(sizeof(struct ListNode));  
            cur = cur->next;  
        }  
        temp = temp->next;  
    }  
    if (cur != NULL) {    
        cur->next = NULL;  
    }  
    return node;  
}
bool isPalindrome(struct ListNode* head) {
    struct ListNode* perv = NULL;
    struct ListNode* node = head;
    struct ListNode* newnode = copy(head);
    while(node != NULL)
    {
        struct ListNode* next = node->next;
        node->next = perv;
        perv = node;
        node = next;
    }
    while(newnode != NULL)
    {
        if(newnode->val != perv->val)
        {
            return false;
        }
        newnode = newnode->next;
        perv = perv->next;
    }
    return true;
}
```

#### 10.环形链表二

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。



 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

 

**提示：**

- 链表中节点的数目范围在范围 `[0, 104]` 内
- `-105 <= Node.val <= 105`
- `pos` 的值为 `-1` 或者链表中的一个有效索引

解答：

```c
struct ListNode *detectCycle(struct ListNode *head) {
    if(head == NULL || head->next == NULL)
    {
        return NULL;
    }
    struct ListNode* first = head;
    struct ListNode* finally = head;
    while(first != NULL && first->next != NULL)
    {
        first = first->next->next;
        finally = finally->next;
        if(first == finally)
        {
            struct ListNode* node = head;
            while(node != finally)
            {
                node = node->next;
                finally = finally->next;
            }
            return node;
        }
    }
    return NULL;
}
```

注：用快慢指针

#### 11.反转链表2

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

**示例 2：**

```
输入：head = [5], left = 1, right = 1
输出：[5]
```

 

**提示：**

- 链表中节点数目为 `n`
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`

解答：

```c
struct ListNode* reverseBetween(struct ListNode* head, int left, int right) {
    if (head == NULL || head->next == NULL || left == right) {
        return head;
    }
    
    struct ListNode dummy;
    dummy.next = head;
    struct ListNode* prev = &dummy;

    for (int i = 0; i < left - 1; i++) {
        prev = prev->next;
    }

    struct ListNode* start = prev->next;
    struct ListNode* then = start->next;

    for (int i = 0; i < right - left; i++) {
        start->next = then->next;
        then->next = prev->next;
        prev->next = then;
        then = start->next;
    }

    return dummy.next;
}
```

### 1.8 栈

栈（也叫堆栈，Stack）是一种特殊的线性表，它只能在在表尾进行插入和删除操作

我们只能在一端进行插入和删除，当我们依次插入1、2、3、4这四个元素后，连续进行四次删除操作，删除的顺序刚好相反：4、3、2、1

底部称为栈底，顶部称为栈顶，所有的操作只能在栈顶进行，也就是说，被压在下方的元素，只能等待其上方的元素出栈之后才能取出，就像我们往箱子里里面放的书一样，因为只有一个口取出里面的物品，所以被压在下面的书只能等上面的书被拿出来之后才能取出，这就是栈的思想，它是一种先进后出的数据结构（FILO，First In, Last Out）

实现栈也是非常简单的，可以基于我们前面的顺序表或是链表，这里我们先使用顺序表来实现一下，这里我们需要实现两个新的操作：

pop：出栈操作，从栈顶取出一个元素。
push：入栈操作，向栈中压入一个新的元素。

#### 1.8.1 用顺序表实现栈

```c
//用顺序表实现栈
typedef int E;
struct stack {
	E* array;
	int capacity;
	int top;
};
typedef struct stack* Arraystack;
_Bool initStack(Arraystack stack) {
    stack->array = malloc(sizeof(E) * 10);
    if (stack->array == NULL) return 0;
    stack->capacity = 10;   //容量还是10
    stack->top = -1;   //由于栈内没有元素，那么栈顶默认就为-1
    return 1;
}
_Bool pushStack(Arraystack stack, E element) {
    if (stack->top + 1 == stack->capacity) {  //栈顶+1如果等于容量的话，那么说明已经塞满了
        int newCapacity = stack->capacity + (stack->capacity >> 1);   //大体操作和顺序表一致
        E* newArray = realloc(stack->array, newCapacity * sizeof(E));
        if (newArray == NULL) return 0;
        stack->array = newArray;
        stack->capacity = newCapacity;
    }
    stack->array[stack->top + 1] = element;
    stack->top++;
    return 1;
}

void printStack(Arraystack stack) {
    printf("| ");
    for (int i = 0; i < stack->top + 1; ++i) {
        printf("%d, ", stack->array[i]);
    }
    printf("\n");
}
_Bool isEmpty(Arraystack stack) {   //在出栈之前，我们还需要使用isEmpty判断一下栈是否为空，空栈元素都没有出个毛
    return stack->top == -1;
}

E popStack(Arraystack stack) {
    return stack->array[stack->top--];   //直接返回栈顶元素，注意多加一个自减操作
}
```

#### 1.8.2 用链表实现栈

```c
typedef int E;

struct ListNode {
    E element;
    struct ListNode * next;
};

typedef struct ListNode * Node;

void initStack(Node head){
    head->next = NULL;
}
_Bool pushStack(Node head, E element){
    Node node = malloc(sizeof(struct ListNode));   //创建新的结点
    if(node == NULL) return 0;   //失败就返回0
    node->next = head->next;   //将当前结点的下一个设定为头结点的下一个
    node->element = element;   //设置元素
    head->next = node;   //将头结点的下一个设定为当前结点
    return 1;
}
void printStack(Node head){
    printf("| ");
    head = head->next;
    while (head){
        printf("%d ", head->element);
        head = head->next;
    }
    printf("\n");
}
_Bool isEmpty(Node head){
    return head->next == NULL;   //判断栈是否为空只需要看头结点下一个是否为NULL即可
}

E popStack(Node head){
    Node top = head->next;
    head->next = head->next->next;
    E e = top->element;
    free(top);  //别忘了释放结点的内存
    return e;   //返回出栈元素
}
```

#### 栈实战：

##### 1.有效括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

 

**示例 1：**

**输入：**s = "()"

**输出：**true

**示例 2：**

**输入：**s = "()[]{}"

**输出：**true

**示例 3：**

**输入：**s = "(]"

**输出：**false

**示例 4：**

**输入：**s = "([])"

**输出：**true

 

**提示：**

- `1 <= s.length <= 104`
- `s` 仅由括号 `'()[]{}'` 组成

解答：

```c
char pairs(char a) {
    if (a == '}') return '{';
    if (a == ']') return '[';
    if (a == ')') return '(';
    return 0;
}
bool isValid(char* s) {
    int n = strlen(s);
    int stk[n + 1], top = 0;
    for (int i = 0; i < n; i++) {
        char ch = pairs(s[i]);
        if (ch) {
            if (top == 0 || stk[top - 1] != ch) {
                return false;
            }
            top--;
        } else {
            stk[top++] = s[i];
        }
    }
    return top == 0;
}
```



### 1.8 队列

#### 1.8.1 用顺序表实现队列

```c
typedef int E;

struct Queue {
    E * array;
    int capacity;   //数组容量
    int rear, front;   //队尾、队首指针
};

typedef struct Queue * ArrayQueue;
_Bool initQueue(ArrayQueue queue){
    queue->array = malloc(sizeof(E) * 10);
    if(queue->array == NULL) return 0;
    queue->capacity = 10;
    queue->front = queue->rear = 0;   //默认情况下队首和队尾都指向0的位置
    return 1;
}
_Bool offerQueue(ArrayQueue queue, E element){
    if((queue->rear + 1) % queue->capacity == queue->front)   //先判断队列是否已满，如果队尾下一个就是队首，那么说明已满
        return 0;
    queue->rear = (queue->rear + 1) % queue->capacity;   //队尾先向前移动一位，注意取余计算才能实现循环
    queue->array[queue->rear] = element;   //在新的位置插入元素
    return 1;
}

void printQueue(ArrayQueue queue){
    printf("<<< ");
    int i = queue->front;   //遍历队列需要从队首开始
    do {
        i = (i + 1) % queue->capacity;   //先向后循环移动
        printf("%d ", queue->array[i]);  //然后打印当前位置上的元素
    } while (i != queue->rear);   //当到达队尾时，结束
    printf("<<<\n");
}
_Bool isEmpty(ArrayQueue queue){   //在出队之前需要先看看容量是否足够
    return queue->rear == queue->front;
}

E pollQueue(ArrayQueue queue){
    queue->front = (queue->front + 1) % queue->capacity;   //先将队首指针后移
    return queue->array[queue->front];   //出队，完事
}
```

#### 1.8.2 用链表实现队列

```c
typedef int E;

struct LNode {
    E element;
    struct LNode * next;
};

typedef struct LNode * Node;

struct Queue{
    Node front, rear;
};

typedef struct Queue * LinkedQueue;   //因为要存储首位两个指针，所以这里封装一个新的结构体吧
_Bool initQueue(LinkedQueue queue){
    Node node = malloc(sizeof(struct LNode));
    if(node == NULL) return 0;
    queue->front = queue->rear = node;   //一开始两个指针都是指向头结点的，表示队列为空
    return 1;
}

_Bool offerQueue(LinkedQueue queue, E element){
    Node node = malloc(sizeof(struct LNode));
    if(node == NULL) return 0;
    node->element = element;
    queue->rear->next = node;   //先让尾结点的下一个指向新的结点
    queue->rear = node;   //然后让队尾指针指向新的尾结点
    return 1;
}
void printQueue(LinkedQueue queue){
    printf("<<< ");
    Node node = queue->front->next;
    while (1) {    //注意不能直接判空，因为前面我们没考虑，也就没将新结点next设定为NULL
        printf("%d ", node->element);
        if(node == queue->rear) break;    //当已经打印最后一个元素后，再结束
        else node = node->next;
    }
    printf("<<<\n");
}
E pollQueue(LinkedQueue queue){
    E e = queue->front->next->element;
    Node node = queue->front->next;
    queue->front->next = queue->front->next->next;  //直接让头结点指向下下个结点
    if(queue->rear == node) queue->rear = queue->front;   //如果队尾就是待出队的结点，那么队尾回到队首位置上
    free(node);   //释放内存
    return e;
}

```

## 2.树型结构

### 2.1 树的介绍

树（Tree）是一种非常重要的非线性数据结构，由结点（Node）和边（Edge）组成，用于表示具有层次结构的关系。树结构广泛应用于计算机科学中的各种场景，如文件系统、数据库索引、表达式解析等。树结构有多个变种，例如二叉树、平衡树、搜索树等。

**树的基本概念**

1. **节点（Node）**：树中的基本元素，每个节点包含两个部分：
   - 数据（value）：节点存储的值。
   - 子节点（children）：从当前节点引出的后继节点。根节点没有父节点，叶子节点没有子节点。
2. **边（Edge）**：连接两个节点之间的线。树中的边没有方向，表示节点之间的层次关系。
3. **根节点（Root）**：树中最顶层的节点。树只有一个根节点，所有其他节点可以通过根节点直接或间接到达。
4. **叶子节点（Leaf Node）**：没有任何子节点的节点，即终端节点。
5. **父节点（Parent）**：直接连接在其上的节点，称为该节点的父节点。
6. **子节点（Child）**：与父节点直接相连的节点称为该节点的子节点。
7. **兄弟节点（Sibling）**：具有同一父节点的节点称为兄弟节点。
8. **路径（Path）**：从一个节点到另一个节点经过的边的序列。
9. **深度（Depth）**：从根节点到当前节点的路径长度（即经过的边数）。
10. **高度（Height）**：从节点到叶子节点的最长路径长度。树的高度是根节点的高度。
11. **层级（Level）**：树中节点的层次，根节点处于第1层，每下一层的节点层级加1。

**树的种类**

1. **普通树（General Tree）**：每个节点可以有任意数量的子节点。
2. **二叉树（Binary Tree）**：每个节点最多只能有两个子节点，通常称为“左子节点”和“右子节点”。
   - **满二叉树（Full Binary Tree）**：每个节点要么是叶子节点，要么有两个子节点。
   - **完全二叉树（Complete Binary Tree）**：所有层的节点都是满的，除了最后一层的叶子节点排列在左边。
   - **平衡二叉树（Balanced Binary Tree）**：任意节点的左右子树高度差不超过1。
   - **二叉搜索树（Binary Search Tree, BST）**：一种特殊的二叉树，满足左子树所有节点小于根节点，右子树所有节点大于根节点。
3. **平衡树（Balanced Tree）**：例如红黑树、AVL树等，这类树通过对树的高度进行自动调整来保持平衡，以提高查找、插入、删除操作的效率。
4. **B树和B+树**：一种用于数据库系统和文件系统中的树结构，适用于磁盘存储。

**树的常见操作**

1. **插入节点（Insertion）**：向树中添加新节点，插入的位置通常与树的种类和结构有关，例如二叉搜索树根据大小决定新节点的插入位置。
2. **删除节点（Deletion）**：从树中移除节点，需要调整树结构保持其性质，例如在删除二叉搜索树的节点时，需要找到合适的节点替代。
3. **遍历（Traversal）**：树的遍历是按一定顺序访问树中的节点。常见的遍历方法有：
   - **前序遍历（Pre-order Traversal）**：先访问根节点，然后递归地访问左子树和右子树。
   - **中序遍历（In-order Traversal）**：先递归访问左子树，再访问根节点，最后访问右子树（对二叉搜索树，中序遍历的结果是有序的）。
   - **后序遍历（Post-order Traversal）**：先递归访问左子树和右子树，最后访问根节点。
   - **层次遍历（Level-order Traversal）**：按层级从上到下依次访问节点。
4. **查找节点（Search）**：根据特定值查找树中的节点，例如二叉搜索树利用其性质可以在O(log n)时间内进行高效查找。

### 2.2 森林的介绍

**森林**（Forest）是树结构的一个延伸概念。简单来说，森林是**多个不相交的树的集合**，即森林中的每棵树是独立的，没有任何一棵树与其他树相连。因此，森林可以被看作是一个由若干棵树组成的集合。

**森林的基本性质**

1. **由树组成**：森林是多个树的集合，因此每棵树本身都具有树的所有性质。每棵树都有根节点、子节点、叶节点等。
2. **可以看作是一棵树的子树集合**：如果你从一棵树中移除根节点，那么剩下的子树将组成一个森林。也就是说，任何树的子树集合本质上就是一个森林。
3. **树与森林的转换**：树和森林之间可以通过操作进行相互转换：
   - 通过把森林中的一棵树的根节点与其他树的根节点相连，可以把森林转化为一棵树。
   - 反之，如果从树的根节点移除连接的边，树会分裂成一个森林（由其所有子树组成）。

**树与森林的关系**

树和森林之间的关系可以从如下几个角度来理解：

- **树是特殊的森林**：如果森林中只有一棵树，那么这个森林实际上就是一棵树。
- **树的子树形成森林**：任何一棵树的每个子树集合都是一个森林。换句话说，从一棵树的根节点向下看，其所有子节点都可以看作一个森林。

**森林的常见操作**

森林的常见操作与树相似，但更适合处理多个树的场景。具体操作有：

1. **合并操作**：可以将两个或多个树通过某种方式合并为一棵树。例如，选取一个新的根节点，将所有树的根节点作为新根节点的子节点。
2. **拆分操作**：可以从一个大树中移除某些节点，从而将这棵树拆分为多个不相交的树，也就是一个森林。例如，从树的根节点移除一条边后，其余子树形成森林。
3. **遍历森林**：遍历森林时可以逐棵遍历每棵树。在每棵树内部可以使用树的各种遍历方法（如前序遍历、中序遍历、后序遍历等），以便依次访问森林中的每个节点。

### 2.3 普通树

普通树（General Tree）是树结构的最基本形式，每个节点可以有任意数量的子节点。普通树没有限制节点的度（即子节点的数量），因此它的结构非常灵活。普通树是各种树结构的基础，比如二叉树、N叉树等特殊树都可以看作是普通树的特例。

#### 普通树的结构

在普通树中，每个节点可以有多个子节点，这些子节点可以再有它们自己的子节点，形成一个递归的层次结构。树的根节点没有父节点，叶子节点没有子节点。

#### 普通树的基本操作

1. **插入节点**：将新节点作为某个父节点的子节点插入。

2. **删除节点**：删除某个节点，同时需要处理该节点的子树。

3. 遍历树

   ：以某种顺序访问树中的所有节点。常见的遍历方式有：

   - **前序遍历**：先访问节点本身，然后访问它的所有子节点。
   - **后序遍历**：先访问节点的所有子节点，再访问节点本身。

#### 普通树的代码实现：

```c
#define  _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
struct TreeNode
{
	char value;
	struct TreeNode* firstChild; // 指向第一个子节点
	struct TreeNode* nextSibling; //指向下一个兄弟节点
};
struct TreeNode* createNode(char value)
{
	struct TreeNode* newnode = malloc(sizeof(struct TreeNode));
	newnode->value = value;
	newnode->firstChild = NULL;
	newnode->nextSibling = NULL;
	return newnode;
}
void addChild(struct TreeNode* parent, struct TreeNode* child)
{
	if (parent->firstChild == NULL)
	{
		parent->firstChild = child;
	}
	else
	{
		struct TreeNode* current = parent->firstChild;
		while (current->nextSibling != NULL)
		{
			current = current->nextSibling;
		}
		current->nextSibling = child;
	}
}
// 前序遍历：先访问当前节点，然后递归访问子节点
void traversePreorder(struct TreeNode* node) {
	if (node == NULL) {
		return;
	}
	printf("%c ", node->value);  // 访问当前节点
	traversePreorder(node->firstChild);  // 递归遍历第一个子节点
	traversePreorder(node->nextSibling); // 递归遍历兄弟节点
}
// 后序遍历：先递归访问子节点，最后访问当前节点
void traversePostorder(struct TreeNode* node) {
	if (node == NULL) {
		return;
	}
	traversePostorder(node->firstChild);  // 递归遍历第一个子节点
	printf("%c ", node->value);           // 访问当前节点
	traversePostorder(node->nextSibling); // 递归遍历兄弟节点
}
// 递归地删除节点及其子节点
void deleteTree(struct TreeNode* node) {
	if (node == NULL) {
		return;
	}
	// 递归删除当前节点的所有子节点
	deleteTree(node->firstChild);
	deleteTree(node->nextSibling);

	// 删除当前节点
	printf("Deleting node: %c\n", node->value);
	free(node);
}
```

### 2.4 满二叉树

#### 满二叉树的定义

满二叉树是指一棵二叉树中，除了叶子节点之外的所有节点都有两个子节点，并且所有的叶子节点都处于同一层。换句话说，满二叉树中的每个非叶子节点都有且只有两个子节点，没有单独存在的一个子节点的情况。

#### 满二叉树的代码实现

```c
struct TreeNode
{
	int value;
	struct TreeNode* left;
	struct TreeNode* right;
};
struct TreeNode* create(int value)
{
	struct TreeNode* newnode = malloc(sizeof(struct TreeNode));
	newnode->value = value;
	newnode->left = NULL;
	newnode->right = NULL;
	return newnode;
}
// 递归创建满二叉树
struct TreeNode* create_full_binary_tree(int current_height, int max_height, int start_value) {
    if (current_height > max_height) {
        return NULL;
    }

    // 创建当前节点
    struct TreeNode* node = create(start_value);

    // 递归创建左子树和右子树，节点值递增
    node->left = create_full_binary_tree(current_height + 1, max_height, start_value * 2);
    node->right = create_full_binary_tree(current_height + 1, max_height, start_value * 2 + 1);

    return node;
}
// 前序遍历二叉树
void pre_order_traversal(struct TreeNode* root) {
    if (root != NULL) {
        printf("%d ", root->value);
        pre_order_traversal(root->left);
        pre_order_traversal(root->right);
    }
}
int main() {
    int max_height = 3; // 设置满二叉树的最大高度

    // 创建满二叉树
    struct TreeNode* root = create_full_binary_tree(1, max_height, 1);

    // 打印树的前序遍历
    printf("满二叉树的前序遍历结果:\n");
    pre_order_traversal(root);
    printf("\n");

    return 0;
}
```

### 2.5 完全二叉树

完全二叉树是一种特殊的二叉树，具有以下特征：

1. **节点排列规则**：完全二叉树的每一层，除了最后一层之外，所有层上的节点都被完全填满，并且最后一层的节点尽可能地集中在左侧。
2. **无空隙**：完全二叉树中的节点从上至下、从左至右排列，最后一层的节点没有“右侧空位”。

完全二叉树与满二叉树的区别在于：

- **满二叉树**要求每一层的节点必须全部填满（即每个非叶子节点都有两个子节点），而完全二叉树只要求节点尽可能靠左填充。

#### **完全二叉树的特点**

1. **节点数量与高度的关系**：
   - 如果完全二叉树的高度为 `h`，则其节点数量范围为 `2^(h-1)`（最小，只有根节点）到 `2^h - 1`（最大，为满二叉树）。
   - 节点数量在高度相同的情况下，完全二叉树的节点数可能小于满二叉树。
2. **最后一层的特点**：
   - 完全二叉树的最后一层可能没有完全填满，但是一旦有节点填充，所有节点必须靠左排列，中间不允许有空位。
3. **数组表示的优势**：
   - 完全二叉树可以用**数组**来高效表示。对于节点 `i`，其左子节点的位置是 `2 * i`，右子节点的位置是 `2 * i + 1`，而父节点的位置为 `i // 2`。
   - 这种表示方式无需存储显式的指针，尤其适合堆结构的实现（如**二叉堆**）。

#### 代码实现

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100  // 假设完全二叉树的最大节点数为100

// 完全二叉树的结构
struct CompleteBinaryTree {
    int nodes[MAX_SIZE];  // 用数组表示二叉树
    int size;             // 当前二叉树中的节点数
};

// 初始化完全二叉树
void initialize_tree(struct CompleteBinaryTree* tree) {
    tree->size = 0;
}

// 插入节点到完全二叉树
void insert_node(struct CompleteBinaryTree* tree, int value) {
    if (tree->size >= MAX_SIZE) {
        printf("树已满，无法插入更多节点。\n");
        return;
    }
    
    tree->nodes[tree->size] = value;  // 将新节点插入到数组末尾
    tree->size++;                     // 更新树的节点数
}

// 前序遍历二叉树 (递归)
void pre_order_traversal(struct CompleteBinaryTree* tree, int index) {
    if (index >= tree->size) {
        return;
    }
    
    printf("%d ", tree->nodes[index]);           // 打印当前节点
    pre_order_traversal(tree, 2 * index + 1);    // 递归遍历左子树
    pre_order_traversal(tree, 2 * index + 2);    // 递归遍历右子树
}

// 中序遍历二叉树 (递归)
void in_order_traversal(struct CompleteBinaryTree* tree, int index) {
    if (index >= tree->size) {
        return;
    }
    
    in_order_traversal(tree, 2 * index + 1);     // 递归遍历左子树
    printf("%d ", tree->nodes[index]);           // 打印当前节点
    in_order_traversal(tree, 2 * index + 2);     // 递归遍历右子树
}

// 后序遍历二叉树 (递归)
void post_order_traversal(struct CompleteBinaryTree* tree, int index) {
    if (index >= tree->size) {
        return;
    }
    
    post_order_traversal(tree, 2 * index + 1);   // 递归遍历左子树
    post_order_traversal(tree, 2 * index + 2);   // 递归遍历右子树
    printf("%d ", tree->nodes[index]);           // 打印当前节点
}

int main() {
    struct CompleteBinaryTree tree;
    initialize_tree(&tree);  // 初始化二叉树
    
    // 插入节点
    insert_node(&tree, 1);
    insert_node(&tree, 2);
    insert_node(&tree, 3);
    insert_node(&tree, 4);
    insert_node(&tree, 5);
    insert_node(&tree, 6);
    
    // 打印二叉树的前序遍历
    printf("前序遍历结果: ");
    pre_order_traversal(&tree, 0);
    printf("\n");
    
    // 打印二叉树的中序遍历
    printf("中序遍历结果: ");
    in_order_traversal(&tree, 0);
    printf("\n");
    
    // 打印二叉树的后序遍历
    printf("后序遍历结果: ");
    post_order_traversal(&tree, 0);
    printf("\n");
    
    return 0;
}
```

### 2.6 二叉搜索树

**二叉搜索树**是一种特殊的二叉树，它具备以下重要特性：

1. **节点值的排序规则**：
   - 对于任意一个节点，其左子树的所有节点的值都小于该节点的值；
   - 右子树的所有节点的值都大于该节点的值。
   - 这个性质确保了在二叉搜索树中进行查找、插入和删除操作时可以利用二分查找的思想，从而达到较高的效率。
2. **没有重复元素**：通常情况下，二叉搜索树不允许有重复的元素。如果插入的元素值相同，通常会按照特定的规则处理，例如不插入或计数。

**二叉搜索树的基本操作**

二叉搜索树的操作包括查找、插入和删除，所有这些操作的平均时间复杂度为 `O(log n)`，最坏情况下退化为 `O(n)`，具体取决于树的平衡性（是否接近于满二叉树）。

**基本操作的逻辑：**

1. **查找（Search）**：
   - 从根节点开始，比较目标值与当前节点的值：
     - 如果相等，则查找成功；
     - 如果目标值小于当前节点值，则递归查找左子树；
     - 如果目标值大于当前节点值，则递归查找右子树。
2. **插入（Insert）**：
   - 插入时，通过递归找到适当的位置（类似查找的过程）：
     - 如果目标值小于当前节点值，递归地插入到左子树；
     - 如果目标值大于当前节点值，递归地插入到右子树。
3. **删除（Delete）**：
   - 删除节点时需要考虑以下三种情况：
     1. **节点无子节点**：直接删除该节点。
     2. **节点有一个子节点**：删除节点并用其子节点代替。
     3. **节点有两个子节点**：找到该节点右子树中的最小值（即**中序后继**），将该值替换到要删除的节点上，然后递归删除该节点右子树中的最小节点。

**代码实现：**

```c
#include <stdio.h>
#include <stdlib.h>

// 定义二叉搜索树的节点结构
struct TreeNode {
    int value;
    struct TreeNode* left;
    struct TreeNode* right;
};

// 创建新节点
struct TreeNode* create_node(int value) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->value = value;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// 插入节点到二叉搜索树
struct TreeNode* insert_node(struct TreeNode* root, int value) {
    if (root == NULL) {
        return create_node(value); // 如果根节点为空，创建新节点
    }
    if (value < root->value) {
        root->left = insert_node(root->left, value); // 递归插入到左子树
    } else if (value > root->value) {
        root->right = insert_node(root->right, value); // 递归插入到右子树
    }
    return root; // 返回更新后的根节点
}

// 查找二叉搜索树中的值
struct TreeNode* search_node(struct TreeNode* root, int value) {
    if (root == NULL || root->value == value) {
        return root; // 查找到或树为空时返回节点
    }
    if (value < root->value) {
        return search_node(root->left, value); // 递归查找左子树
    } else {
        return search_node(root->right, value); // 递归查找右子树
    }
}

// 查找最小值节点（用于删除操作）
struct TreeNode* find_min(struct TreeNode* root) {
    while (root->left != NULL) {
        root = root->left; // 找到最左端的节点
    }
    return root;
}

// 删除节点
struct TreeNode* delete_node(struct TreeNode* root, int value) {
    if (root == NULL) {
        return root;
    }
    if (value < root->value) {
        root->left = delete_node(root->left, value); // 递归删除左子树的节点
    } else if (value > root->value) {
        root->right = delete_node(root->right, value); // 递归删除右子树的节点
    } else {
        // 找到要删除的节点
        if (root->left == NULL) {
            // 只有右子树或无子树
            struct TreeNode* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            // 只有左子树
            struct TreeNode* temp = root->left;
            free(root);
            return temp;
        }
        // 有两个子节点
        struct TreeNode* temp = find_min(root->right); // 找到右子树中的最小值
        root->value = temp->value; // 用最小值替换当前节点
        root->right = delete_node(root->right, temp->value); // 递归删除最小值节点
    }
    return root;
}

// 中序遍历二叉搜索树
void in_order_traversal(struct TreeNode* root) {
    if (root != NULL) {
        in_order_traversal(root->left);
        printf("%d ", root->value);
        in_order_traversal(root->right);
    }
}

int main() {
    struct TreeNode* root = NULL;
    
    // 插入节点
    root = insert_node(root, 50);
    root = insert_node(root, 30);
    root = insert_node(root, 70);
    root = insert_node(root, 20);
    root = insert_node(root, 40);
    root = insert_node(root, 60);
    root = insert_node(root, 80);
    
    // 中序遍历，打印有序的节点值
    printf("中序遍历结果: ");
    in_order_traversal(root);
    printf("\n");
    
    // 查找节点
    int search_value = 40;
    if (search_node(root, search_value)) {
        printf("值 %d 存在于二叉搜索树中。\n", search_value);
    } else {
        printf("值 %d 不存在于二叉搜索树中。\n", search_value);
    }
    
    // 删除节点
    printf("删除值 50 后的中序遍历结果: ");
    root = delete_node(root, 50);
    in_order_traversal(root);
    printf("\n");
    
    return 0;
}
```

### 2.7 平衡二叉树

**平衡二叉树**是一种特殊的二叉搜索树，旨在保持树的高度平衡，以确保在进行插入、删除和查找操作时，树的高度不会过高，从而保持较高的操作效率。平衡二叉树的基本思想是通过限制树的高度，避免退化为链表，从而使得查找、插入、删除等操作的时间复杂度接近 `O(log n)`，其中 `n` 是树中节点的数量。

#### 平衡二叉树的定义

对于任何一个平衡二叉树中的节点，**它的左子树和右子树的高度差不超过1**。这意味着该树是尽可能"平衡"的，尽管不是每棵二叉搜索树都能满足这个条件，但平衡二叉树通过各种调整算法，使得插入和删除操作后依然保持平衡状态。

#### 平衡二叉树的类型

1. **AVL树**：
   - 由G. M. Adelson-Velsky和E. M. Landis在1962年提出，是第一种自平衡二叉搜索树。
   - 特性：对于每个节点，要求其左右子树的高度差（**平衡因子**）最多为1。
   - 平衡因子：某个节点的平衡因子等于它左子树的高度减去右子树的高度。
   - 在插入或删除节点时，如果某个节点的平衡因子不再满足条件（即平衡因子变为-2或2），则需要通过**旋转（rotation）**操作来重新平衡该树。
2. **红黑树**：
   - 是一种用于保持二叉搜索树平衡的高效平衡树。
   - 特性：通过节点着色（红色或黑色）和一组规则确保树的大致平衡，红黑树的高度不会超过 `2log(n)`。
   - 红黑树广泛用于实际工程中，常见的例子有Java中的`TreeMap`、`TreeSet`，C++中的`map`和`set`。
3. **Splay树**：
   - 是一种自调整的平衡二叉搜索树。
   - 特性：每次查找或插入后，经过特定的“旋转”操作，将被访问的节点旋转到根部，以便将最近访问的节点保留在更高层次。
4. **B树和B+树**（常用于数据库系统和文件系统中）：
   - 它们并非严格意义上的二叉树，但它们也是平衡树结构，用于维护大型数据集的平衡，确保查找、插入、删除操作在 `O(log n)` 时间复杂度内完成。

#### 旋转操作（用于保持树的平衡）

平衡二叉树中的插入和删除操作，可能导致树失衡，此时需要通过**旋转**操作来恢复平衡性。旋转分为两类：**单旋转**和**双旋转**。

1. **单旋转**：
   - **左旋转**：当右子树比左子树高，需要进行左旋转。
   - **右旋转**：当左子树比右子树高，需要进行右旋转。
2. **双旋转**：
   - 当情况更加复杂时（比如插入或删除节点导致的非局部失衡），需要通过两次旋转操作恢复平衡。
   
   在平衡二叉树（如AVL树）中，旋转操作是用来保持树的平衡的。当插入或删除节点时，如果某些子树的高度差超过1，树就会变得不平衡，这时就需要进行旋转操作来恢复平衡。常见的旋转操作有以下四种：
   
   1. **单右旋转（Single Right Rotation，RR旋转）**
      适用于左子树过高的情况。当某个节点的左子树比右子树高两层时，我们对该节点执行一次右旋转。
   
      **操作步骤**：
   
      - 假设不平衡的节点为`A`，它的左子节点为`B`。
      - 右旋转后，`B`成为新的根，`A`成为`B`的右子节点，`B`的右子树成为`A`的左子树。
   
   2. **单左旋转（Single Left Rotation，LL旋转）**
      适用于右子树过高的情况。当某个节点的右子树比左子树高两层时，我们对该节点执行一次左旋转。
   
      **操作步骤**：
   
      - 假设不平衡的节点为`A`，它的右子节点为`B`。
      - 左旋转后，`B`成为新的根，`A`成为`B`的左子节点，`B`的左子树成为`A`的右子树。
   
   3. **左-右旋转（Left-Right Rotation，LR旋转）**
      适用于左子树的右子树过高的情况。此时我们需要先对左子节点进行一次左旋转，然后对当前不平衡节点进行一次右旋转。
   
      **操作步骤**：
   
      - 假设不平衡的节点为`A`，`A`的左子节点为`B`，而`B`的右子节点为`C`。
      - 先对`B`进行一次左旋转，使`C`成为`B`的父节点。
      - 然后对`A`进行一次右旋转，使`C`成为`A`的父节点。
   
   4. **右-左旋转（Right-Left Rotation，RL旋转）**
      适用于右子树的左子树过高的情况。此时我们需要先对右子节点进行一次右旋转，然后对当前不平衡节点进行一次左旋转。
   
      **操作步骤**：
   
      - 假设不平衡的节点为`A`，`A`的右子节点为`B`，而`B`的左子节点为`C`。
      - 先对`B`进行一次右旋转，使`C`成为`B`的父节点。
      - 然后对`A`进行一次左旋转，使`C`成为`A`的父节点。

#### 平衡二叉树的基本操作

**1. 插入操作**

- 当在树中插入新节点时，可能会破坏平衡，因此需要根据插入节点的位置，判断是否需要旋转并执行旋转操作，重新恢复平衡。

**2. 删除操作**

- 删除节点时同样可能导致树失衡，删除节点后，需要检测其父节点和祖先节点的平衡因子，并根据情况调整结构，通过旋转操作保持平衡。

**3. 查找操作**

- 查找操作依然遵循二叉搜索树的查找规则，沿着树的左右分支进行递归查找。

### 2.8 AVL树

```c
#include <stdio.h>
#include <stdlib.h>

// AVL树节点结构
struct TreeNode {
    int value;
    struct TreeNode* left;
    struct TreeNode* right;
    int height;  // 记录节点的高度
};

// 获取节点的高度
int height(struct TreeNode* node) {
    if (node == NULL) {
        return 0;
    }
    return node->height;
}

// 计算两个数的最大值
int max(int a, int b) {
    return (a > b) ? a : b;
}

// 创建新节点
struct TreeNode* create_node(int value) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->value = value;
    newNode->left = NULL;
    newNode->right = NULL;
    newNode->height = 1;  // 新节点的高度初始化为1
    return newNode;
}

// 右旋转操作
struct TreeNode* right_rotate(struct TreeNode* y) {
    struct TreeNode* x = y->left;
    struct TreeNode* T2 = x->right;

    // 旋转操作
    x->right = y;
    y->left = T2;

    // 更新高度
    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;

    // 返回新的根节点
    return x;
}

// 左旋转操作
struct TreeNode* left_rotate(struct TreeNode* x) {
    struct TreeNode* y = x->right;
    struct TreeNode* T2 = y->left;

    // 旋转操作
    y->left = x;
    x->right = T2;

    // 更新高度
    x->height = max(height(x->left), height(x->right)) + 1;
    y->height = max(height(y->left), height(y->right)) + 1;

    // 返回新的根节点
    return y;
}

// 计算节点的平衡因子
int get_balance(struct TreeNode* node) {
    if (node == NULL) {
        return 0;
    }
    return height(node->left) - height(node->right);
}

// 插入节点到AVL树并保持平衡
struct TreeNode* insert_node(struct TreeNode* node, int value) {
    if (node == NULL) {
        return create_node(value);
    }

    // 递归插入节点
    if (value < node->value) {
        node->left = insert_node(node->left, value);
    } else if (value > node->value) {
        node->right = insert_node(node->right, value);
    } else {
        return node;  // 不允许插入相同的值
    }

    // 更新当前节点的高度
    node->height = 1 + max(height(node->left), height(node->right));

    // 获取当前节点的平衡因子
    int balance = get_balance(node);

    // 旋转操作以保持平衡
    // 左左情况（左子树高，插入到左子树的左边）
    if (balance > 1 && value < node->left->value) {
        return right_rotate(node);
    }

    // 右右情况（右子树高，插入到右子树的右边）
    if (balance < -1 && value > node->right->value) {
        return left_rotate(node);
    }

    // 左右情况（左子树高，插入到左子树的右边）
    if (balance > 1 && value > node->left->value) {
        node->left = left_rotate(node->left);
        return right_rotate(node);
    }

    // 右左情况（右子树高，插入到右子树的左边）
    if (balance < -1 && value < node->right->value) {
        node->right = right_rotate(node->right);
        return left_rotate(node);
    }

    // 返回更新后的节点
    return node;
}

// 中序遍历AVL树
void in_order_traversal(struct TreeNode* root) {
    if (root != NULL) {
        in_order_traversal(root->left);
        printf("%d ", root->value);
        in_order_traversal(root->right);
    }
}

int main() {
    struct TreeNode* root = NULL;

    // 插入节点
    root = insert_node(root, 10);
    root = insert_node(root, 20);
    root = insert_node(root, 30);
    root = insert_node(root, 40);
    root = insert_node(root, 50);
    root = insert_node(root, 25);

    // 中序遍历，打印有序的节点值
    printf("中序遍历AVL树: ");
    in_order_traversal(root);
    printf("\n");

    return 0;
}
```

### 2.9 红黑树

**红黑树**是一种自平衡的二叉搜索树，具有高度平衡性，并且通过一组规则来保证树的大致平衡性。红黑树广泛用于实际系统中，如Java的`TreeMap`、`TreeSet`，C++的`map`和`set`，数据库中的索引等。红黑树的主要优势是它能够保证最坏情况下的操作时间复杂度为 `O(log n)`，包括插入、删除、查找等操作。

**红黑树的性质**

红黑树在保持平衡的过程中，采用了一种节点着色机制（红色或黑色）以及一组规则。它具有以下五个性质：

1. **节点是红色或黑色**：
   - 每个节点必须被着色为红色或黑色，这种颜色用来帮助树保持平衡。
2. **根节点是黑色**：
   - 红黑树的根节点始终是黑色。
3. **所有叶子节点（`NULL`节点）是黑色**：
   - 红黑树中的所有叶子节点（即`NULL`指针，表示不存在的子节点）都被认为是黑色的。
4. **红色节点的子节点必须是黑色**：
   - 这也称为“**红色节点不能有红色子节点**”的性质，即树中不能有两个连续的红色节点（从根到叶子的路径上，红色节点之间必须隔着黑色节点）。
5. **从任一节点到其所有叶子节点的路径上包含相同数目的黑色节点**：
   - 这个性质称为“**黑色平衡**”，它确保从根到任意叶子节点的路径长度不会有极大差异，保持了树的平衡性。

**红黑树的插入和删除操作**

红黑树的插入和删除是比较复杂的过程，它们都需要在树中保持红黑树的平衡性。通常情况下，插入和删除操作会破坏红黑树的性质，此时需要通过**颜色转换**和**旋转**操作来恢复红黑树的平衡。

1. **插入操作**：
   - 新插入的节点通常着色为红色。
   - 如果插入节点的父节点也是红色，可能会违反红黑树的性质，需要通过**重新着色**或**旋转**来恢复平衡。
2. **删除操作**：
   - 删除操作同样可能会破坏红黑树的平衡，特别是当删除黑色节点时，需要通过旋转和重新着色等操作恢复树的平衡。

**旋转操作**

红黑树使用旋转操作来保持平衡性，旋转分为**左旋转**和**右旋转**两种。旋转的目标是保持树的高度平衡，并重新调整节点的父子关系。

- **左旋转**：将某个节点的右子节点提升为父节点，并将原父节点作为右子节点的左子节点。
- **右旋转**：将某个节点的左子节点提升为父节点，并将原父节点作为左子节点的右子节点。

**红黑树的性能**

红黑树的高度始终保持在 `O(log n)` 级别。尽管红黑树不总是严格平衡（与AVL树相比），但它能够保证较好的性能，特别是删除和插入操作的效率更高。

**红黑树的操作时间复杂度：**

- **查找**：`O(log n)`，遵循二叉搜索树的查找规则，利用节点的大小关系递归搜索左右子树。
- **插入**：`O(log n)`，通过颜色调整和旋转来保持树的平衡。
- **删除**：`O(log n)`，通过重新着色和旋转操作来恢复红黑树的性质。

**红黑树的应用场景**

由于红黑树在最坏情况下仍然能够保证操作时间复杂度为 `O(log n)`，因此它被广泛用于需要高效查找、插入和删除操作的场景：

1. **Java的`TreeMap`和`TreeSet`**：红黑树是`TreeMap`和`TreeSet`的底层实现，保证元素按顺序存储并具有高效的查找、插入和删除操作。
2. **C++ STL中的`map`和`set`**：在C++标准库中，`map`和`set`等容器的底层也是通过红黑树实现的。
3. **数据库索引**：红黑树常用于数据库的索引结构，帮助快速查找记录。
4. **操作系统中的进程调度**：在一些操作系统中，红黑树用于管理进程调度队列，提供高效的调度决策。

**红黑树的C语言实现**

以下是红黑树的一部分C语言实现，包含插入操作和一些辅助函数：

```c
#include <stdio.h>
#include <stdlib.h>

// 定义红黑树节点的颜色
typedef enum { RED, BLACK } Color;

// 红黑树节点结构
struct TreeNode {
    int value;
    Color color;
    struct TreeNode* left;
    struct TreeNode* right;
    struct TreeNode* parent;
};

// 创建新节点
struct TreeNode* create_node(int value) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->value = value;
    newNode->color = RED;  // 新插入的节点初始为红色
    newNode->left = NULL;
    newNode->right = NULL;
    newNode->parent = NULL;
    return newNode;
}

// 左旋操作
void left_rotate(struct TreeNode** root, struct TreeNode* x) {
    struct TreeNode* y = x->right; // y是x的右子节点
    x->right = y->left;
    if (y->left != NULL) {
        y->left->parent = x;
    }
    y->parent = x->parent;
    if (x->parent == NULL) {
        *root = y; // y成为新的根节点
    } else if (x == x->parent->left) {
        x->parent->left = y;
    } else {
        x->parent->right = y;
    }
    y->left = x;
    x->parent = y;
}

// 右旋操作
void right_rotate(struct TreeNode** root, struct TreeNode* y) {
    struct TreeNode* x = y->left; // x是y的左子节点
    y->left = x->right;
    if (x->right != NULL) {
        x->right->parent = y;
    }
    x->parent = y->parent;
    if (y->parent == NULL) {
        *root = x; // x成为新的根节点
    } else if (y == y->parent->right) {
        y->parent->right = x;
    } else {
        y->parent->left = x;
    }
    x->right = y;
    y->parent = x;
}

// 插入修复函数，保持红黑树的平衡
void insert_fixup(struct TreeNode** root, struct TreeNode* z) {
    while (z->parent != NULL && z->parent->color == RED) {
        if (z->parent == z->parent->parent->left) {
            struct TreeNode* y = z->parent->parent->right; // z的叔叔节点
            if (y != NULL && y->color == RED) { // 情况1: 叔叔节点是红色
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else { // 叔叔节点是黑色或NULL
                if (z == z->parent->right) { // 情况2: z是右子节点
                    z = z->parent;
                    left_rotate(root, z);
                }
                // 情况3: z是左子节点
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                right_rotate(root, z->parent->parent);
            }
        } else {
            struct TreeNode* y = z->parent->parent->left; // z的叔叔节点
            if (y != NULL && y->color == RED) { // 情况1: 叔叔节点是红色
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                if (z == z->parent->left) { // 情况2: z是左子节点
                    z = z->parent;
                    right_rotate(root, z);
                }
                // 情况3: z是右子节点
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                left_rotate(root, z->parent->parent);
            }
        }
    }
    (*root)->color = BLACK; // 保证根节点是黑色
}

// 插入节点
void insert_node(struct TreeNode** root, int value) {
    struct TreeNode* z = create_node(value);
    struct TreeNode* y = NULL;
    struct TreeNode* x = *root;

    while (x != NULL) {
        y = x;
        if (z->value < x->value) {
            x = x->left;
        } else {
            x = x->right;
        }
    }

    z->parent = y;
    if (y == NULL) {
        *root = z; // 插入的节点为根节点
    } else if (z->value < y->value) {
        y->left = z;
    } else {
        y->right = z;
    }

    insert_fixup(root, z); // 调用修复函数保证红黑树性质
}

// 中序遍历红黑树
void in_order_traversal(struct TreeNode* root) {
    if (root != NULL) {
        in_order_traversal(root->left);
        printf("%d ", root->value);
        in_order_traversal(root->right);
    }
}

int main() {
    struct TreeNode* root = NULL;

    // 插入节点
    insert_node(&root, 10);
    insert_node(&root, 20);
    insert_node(&root, 30);
    insert_node(&root, 15);

    // 中序遍历红黑树
    printf("中序遍历红黑树: ");
    in_order_traversal(root);
    printf("\n");

    return 0;
}
```

### 2.10 Splay树

**Splay树**是一种自调整的二叉搜索树，它通过一种特定的操作（称为**伸展操作**，即 **Splaying**），将最近访问的节点提升到树的根部。Splay树能够在不需要额外存储平衡因子的情况下，保持较好的性能，并且在一些特定的场景下表现非常优异，比如访问具有局部性的数据或频繁访问相同元素的数据。

**Splay树的特点**

1. **自调整**：每次查找、插入或删除后，Splay树都会将目标节点移动到根节点。这种自调整机制可以让Splay树对最近被访问的节点更高效。
2. **伸展操作**：Splay树的核心操作是“**伸展**”，通过一系列旋转操作（包括**单旋转**和**双旋转**）将被访问的节点移到树的根部。
3. **局部性原理**：Splay树对具有局部性访问模式的数据特别高效。如果某些节点被频繁访问，它们会自动移动到树的上层，从而加快后续访问这些节点的速度。
4. **平摊复杂度**：Splay树的所有操作（包括查找、插入、删除）在单个操作上的最坏时间复杂度可能是 `O(n)`，但它的平摊时间复杂度是 `O(log n)`，其中 `n` 是树中的节点数。平摊复杂度表示的是对一系列操作的平均性能，因此Splay树在长期使用中表现良好。

**Splay树的基本操作**

1. **伸展操作（Splay）**

伸展操作是Splay树的核心，通过将某个节点旋转到根节点来调整树的结构。根据目标节点相对于其父节点和祖父节点的位置，伸展操作分为三种情况：

- **Zig（单旋转）**：
  - 当目标节点是树的根节点的直接子节点时，只需要进行一次旋转将其移到根部。
- **Zig-Zig（双旋转）**：
  - 当目标节点和其父节点都在其祖父节点的左子树或右子树时，需要连续两次旋转。先对祖父节点进行旋转，再对父节点进行旋转。
- **Zig-Zag（双旋转）**：
  - 当目标节点位于其父节点的左子树，而其父节点位于祖父节点的右子树（或相反）时，先对父节点进行一次旋转，再对祖父节点进行一次旋转。

2. **查找操作**

查找某个节点的过程与普通的二叉搜索树相似，不同之处在于查找到该节点后，需要对该节点执行伸展操作，将其移到树的根部。查找的平均时间复杂度是 `O(log n)`，但是在最坏情况下可能是 `O(n)`。

3. **插入操作**

插入操作与普通的二叉搜索树相同，但在插入后需要对新插入的节点执行伸展操作，将其移到根部。插入的平摊时间复杂度是 `O(log n)`。

4. **删除操作**

删除节点时，首先执行伸展操作将要删除的节点移到根部，然后删除根节点。删除后，将左子树和右子树重新连接起来，并使其中一个子树成为新的根。删除操作的平摊时间复杂度也是 `O(log n)`。

**Splay树的优点和缺点**

**优点：**

1. **无需平衡因子**：与AVL树和红黑树不同，Splay树不需要存储额外的平衡因子，结构更简单。
2. **局部性优化**：Splay树对具有局部性访问的应用特别有效。如果某些节点被频繁访问，它们会自动被调整到靠近根部的位置。
3. **平摊复杂度低**：Splay树的所有操作都具有 `O(log n)` 的平摊时间复杂度，因此在一系列操作中的性能非常好。
4. **简单实现**：由于不需要复杂的平衡调整，Splay树相对简单，适合实现自调整数据结构。

**缺点：**

1. **最坏情况性能较差**：虽然Splay树的平摊时间复杂度是 `O(log n)`，但单次操作的最坏情况可能是 `O(n)`，当树非常不平衡时性能可能较差。
2. **对静态数据表现较差**：对于静态数据集（即没有频繁修改或访问的场景），Splay树的性能可能不如其他平衡二叉树（如红黑树或AVL树）。

```c
#include <stdio.h>
#include <stdlib.h>

// 定义Splay树节点结构
struct TreeNode {
    int value;
    struct TreeNode* left;
    struct TreeNode* right;
};

// 创建新节点
struct TreeNode* create_node(int value) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->value = value;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// 右旋转操作
struct TreeNode* right_rotate(struct TreeNode* x) {
    struct TreeNode* y = x->left;
    x->left = y->right;
    y->right = x;
    return y;
}

// 左旋转操作
struct TreeNode* left_rotate(struct TreeNode* x) {
    struct TreeNode* y = x->right;
    x->right = y->left;
    y->left = x;
    return y;
}

// 伸展操作（Splay），将节点提升到根
struct TreeNode* splay(struct TreeNode* root, int value) {
    if (root == NULL || root->value == value) {
        return root;
    }

    // 左子树中查找
    if (value < root->value) {
        if (root->left == NULL) {
            return root;
        }
        // Zig-Zig（左左情况）
        if (value < root->left->value) {
            root->left->left = splay(root->left->left, value);
            root = right_rotate(root);
        }
        // Zig-Zag（左右情况）
        else if (value > root->left->value) {
            root->left->right = splay(root->left->right, value);
            if (root->left->right != NULL) {
                root->left = left_rotate(root->left);
            }
        }
        return (root->left == NULL) ? root : right_rotate(root);
    }

    // 右子树中查找
    else {
        if (root->right == NULL) {
            return root;
        }
        // Zag-Zig（右左情况）
        if (value < root->right->value) {
            root->right->left = splay(root->right->left, value);
            if (root->right->left != NULL) {
                root->right = right_rotate(root->right);
            }
        }
        // Zag-Zag（右右情况）
        else if (value > root->right->value) {
            root->right->right = splay(root->right->right, value);
            root = left_rotate(root);
        }
        return (root->right == NULL) ? root : left_rotate(root);
    }
}

// 查找节点并进行伸展
struct TreeNode* search(struct TreeNode* root, int value) {
    return splay(root, value);
}

// 插入新节点
struct TreeNode* insert_node(struct TreeNode* root, int value) {
    if (root == NULL) {
        return create_node(value);
    }
    root = splay(root, value);
    if (root->value == value) {
        return root;  // 值已存在
    }
    
    struct TreeNode* newNode = create_node(value);
    if (value < root->value) {
        newNode->right = root;
        newNode->left = root->left;
        root->left = NULL;
    } else {
        newNode->left = root;
        newNode->right = root->right;
        root->right = NULL;
    }
    return newNode;
}

// 中序遍历Splay树
void in_order_traversal(struct TreeNode* root) {
    if (root != NULL) {
        in_order_traversal(root->left);
        printf("%d ", root->value);
        in_order_traversal(root->right);
    }
}

int main() {
    struct TreeNode* root = NULL;

    // 插入节点
    root = insert_node(root, 100);
    root = insert_node(root, 50);
    root = insert_node(root, 200);
    root = insert_node(root, 40);
    root = insert_node(root, 60);
    root = insert_node(root, 150);
    root = insert_node(root, 250);

    // 中序遍历
    printf("中序遍历: ");
    in_order_traversal(root);
    printf("\n");

    // 查找节点并进行伸展
    root = search(root, 60);
    printf("查找并伸展节点60后的中序遍历: ");
    in_order_traversal(root);
    printf("\n");

    return 0;
}
```

### 2.11 霍夫曼树

霍夫曼树（Huffman Tree）是一种用于数据压缩的二叉树，也称为最优二叉树或编码树。它通过构建一种编码方式，使得出现频率高的字符使用较短的编码，而出现频率低的字符使用较长的编码，从而实现无损压缩。

**霍夫曼树的基本概念**

- **霍夫曼编码**是一种前缀编码，也就是说任何一个字符的编码都不会是另一个字符编码的前缀。
- 霍夫曼树是一个**带权路径长度最短**的二叉树。路径长度指的是从根节点到叶节点的边数，而带权路径长度是将路径长度乘以该节点的权值（通常是频率），然后求和。
- 通过霍夫曼树，可以对每个字符生成一种唯一的二进制编码，这些编码不会有冲突。

**霍夫曼树的构建过程**

霍夫曼树的构建基于贪心算法，具体步骤如下：

1. **统计频率**
   - 统计每个字符的出现频率，将每个字符和其频率当作一个节点。频率将作为节点的权值。
2. **初始化节点**
   - 把每个字符及其频率构成的节点放入一个**优先队列**（或小顶堆）中，以频率（权值）为依据进行排序。
3. **构建树**
   - 重复以下步骤，直到队列中只剩下一个节点：
     1. 从优先队列中取出两个权值最小的节点作为树的左子节点和右子节点。
     2. 创建一个新的父节点，其权值为左右子节点权值之和。
     3. 将这个新节点放入优先队列中。
   - 最后剩下的唯一节点即为霍夫曼树的根节点。
4. **生成编码**
   - 从根节点开始，通过左子节点赋值“0”，右子节点赋值“1”，直到到达叶节点时形成该字符的霍夫曼编码。

**霍夫曼编码示例**

假设有以下字符和对应的频率：

| 字符 | 频率 |
| ---- | ---- |
| A    | 5    |
| B    | 9    |
| C    | 12   |
| D    | 13   |
| E    | 16   |
| F    | 45   |

**构建过程**

1. 初始化时将每个字符作为单独的节点放入优先队列。
2. 每次取出两个频率最小的节点合并成一个新节点，直到形成整棵树。
   - 第一次合并：A (5) 和 B (9) 生成新节点 (14)
   - 第二次合并：C (12) 和新节点 (14) 生成新节点 (26)
   - 第三次合并：D (13) 和 E (16) 生成新节点 (29)
   - 第四次合并：新节点 (26) 和新节点 (29) 生成新节点 (55)
   - 第五次合并：F (45) 和新节点 (55) 生成根节点 (100)

**编码结果**

根据最终的霍夫曼树，从根节点开始，通过左侧标记“0”、右侧标记“1”，可以得到每个字符的编码。例如：

- A: 1100
- B: 1101
- C: 100
- D: 101
- E: 111
- F: 0

**霍夫曼编码的应用**

霍夫曼编码主要用于数据压缩，常见的应用包括：

- **文件压缩**：如 ZIP、RAR 等格式中应用霍夫曼编码来减少文件大小。
- **图像与视频压缩**：如 JPEG、MP3、MPEG 等格式中，用霍夫曼编码对数据流进行压缩。

**霍夫曼编码的优点和局限**

- 优点
  - 霍夫曼编码能够显著减少数据的存储量，特别适合频率分布不均匀的数据。
  - 是一种无损压缩编码，能够精确还原原始数据。
- 局限
  - 对于频率接近或频率分布均匀的数据，压缩效率不高。
  - 需要预先扫描数据以统计频率，不适合实时动态编码的应用场景。

霍夫曼树通过利用字符的频率分布特点，使得压缩编码达到最优，同时确保编码不产生冲突。

**霍夫曼树的实现**

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

// 定义节点结构体
typedef struct Node {
    char character;          // 字符
    int frequency;           // 频率
    struct Node *left;       // 左子节点
    struct Node *right;      // 右子节点
} Node;

// 创建节点
Node* createNode(char character, int frequency) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->character = character;
    node->frequency = frequency;
    node->left = node->right = NULL;
    return node;
}

// 定义优先队列结构体
typedef struct PriorityQueue {
    Node* array[MAX_SIZE];
    int size;
} PriorityQueue;

// 创建优先队列
PriorityQueue* createPriorityQueue() {
    PriorityQueue* queue = (PriorityQueue*)malloc(sizeof(PriorityQueue));
    queue->size = 0;
    return queue;
}

// 插入节点到优先队列中
void insertPriorityQueue(PriorityQueue* queue, Node* node) {
    int i = queue->size++;
    while (i > 0 && queue->array[(i - 1) / 2]->frequency > node->frequency) {
        queue->array[i] = queue->array[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->array[i] = node;
}

// 从优先队列中取出频率最小的节点
Node* extractMin(PriorityQueue* queue) {
    Node* minNode = queue->array[0];
    Node* lastNode = queue->array[--queue->size];

    int i = 0, child;
    while ((child = 2 * i + 1) < queue->size) {
        if (child + 1 < queue->size && queue->array[child + 1]->frequency < queue->array[child]->frequency) {
            child++;
        }
        if (lastNode->frequency <= queue->array[child]->frequency) break;
        queue->array[i] = queue->array[child];
        i = child;
    }
    queue->array[i] = lastNode;
    return minNode;
}

// 构建霍夫曼树
Node* buildHuffmanTree(char characters[], int frequencies[], int size) {
    PriorityQueue* queue = createPriorityQueue();
    
    for (int i = 0; i < size; i++) {
        insertPriorityQueue(queue, createNode(characters[i], frequencies[i]));
    }

    while (queue->size > 1) {
        Node* left = extractMin(queue);
        Node* right = extractMin(queue);
        Node* newNode = createNode('\0', left->frequency + right->frequency);
        newNode->left = left;
        newNode->right = right;
        insertPriorityQueue(queue, newNode);
    }

    return extractMin(queue);
}

// 生成霍夫曼编码
void generateHuffmanCodes(Node* root, char* code, int depth) {
    if (root->left == NULL && root->right == NULL) {
        code[depth] = '\0';
        printf("字符: %c -> 编码: %s\n", root->character, code);
        return;
    }

    if (root->left != NULL) {
        code[depth] = '0';
        generateHuffmanCodes(root->left, code, depth + 1);
    }
    if (root->right != NULL) {
        code[depth] = '1';
        generateHuffmanCodes(root->right, code, depth + 1);
    }
}

// 主函数
int main() {
    char characters[] = { 'A', 'B', 'C', 'D', 'E', 'F' };
    int frequencies[] = { 5, 9, 12, 13, 16, 45 };
    int size = sizeof(characters) / sizeof(characters[0]);

    // 构建霍夫曼树
    Node* root = buildHuffmanTree(characters, frequencies, size);

    // 生成并打印霍夫曼编码
    char code[MAX_SIZE];
    generateHuffmanCodes(root, code, 0);

    return 0;
}
```

### 2.12 线索二叉树

**线索二叉树**（Threaded Binary Tree）是一种特殊的二叉树，其特点是将空的左、右子指针用线索代替，使得树在中序遍历时可以在O(1)时间内找到节点的前驱和后继节点。这种设计可以加速遍历过程，避免递归调用和栈的开销。

**线索二叉树的基本概念**

1. **线索化**
   - 线索二叉树的节点中，若某个节点的左或右子指针为空，那么该空指针就会指向该节点在某种遍历方式（如中序遍历）下的前驱或后继节点，这种指向被称为“线索”。
   - 根据所用遍历方式的不同，线索二叉树可以分为中序线索二叉树、前序线索二叉树和后序线索二叉树。其中，中序线索二叉树最常见。
2. **线索的表示**
   - 每个节点需要额外两个标志位（或使用其他方法标记），用来指示左、右子指针是否为线索：
     - 左线索标志位（`lTag`）：若`lTag`为0，则左指针指向左子节点；若为1，则表示该指针指向该节点的前驱。
     - 右线索标志位（`rTag`）：若`rTag`为0，则右指针指向右子节点；若为1，则表示该指针指向该节点的后继。
3. **线索化的过程**
   - 线索化的过程是在遍历二叉树的同时，对节点进行线索化，将空指针填入指向前驱或后继节点的线索。
   - 在线索二叉树的构建过程中需要记录当前访问节点的前一个节点（`pre`节点），以便为每个节点建立正确的前驱或后继关系。

**中序线索二叉树的构建**

中序线索二叉树的构建过程如下：

1. 先定义一个全局或静态指针`pre`，用来保存当前节点的前一个节点。
2. 对树进行中序遍历，并在线索化过程中填充前驱和后继信息：
   - 若当前节点的左子指针为空，则将其左子指针指向`pre`节点，并将左线索标志位置为1。
   - 若`pre`节点的右子指针为空，则将其右子指针指向当前节点，并将右线索标志位置为1。
3. 更新`pre`指针，使其指向当前节点。

**线索二叉树的定义与实现**

以下是线索二叉树的结构定义和构建过程的实现示例：

```c
#include <stdio.h>
#include <stdlib.h>

// 定义线索二叉树节点
typedef struct ThreadedNode {
    int data;                 // 节点数据
    struct ThreadedNode *left, *right; // 左右子指针
    int lTag, rTag;           // 左右线索标志
} ThreadedNode;

// 初始化节点
ThreadedNode* createNode(int data) {
    ThreadedNode* node = (ThreadedNode*)malloc(sizeof(ThreadedNode));
    node->data = data;
    node->left = node->right = NULL;
    node->lTag = node->rTag = 0;
    return node;
}

ThreadedNode *pre = NULL;  // 用于保存前一个节点

// 中序线索化
void inThreading(ThreadedNode *node) {
    if (node == NULL) return;

    // 线索化左子树
    inThreading(node->left);

    // 如果当前节点的左指针为空，将其指向前驱节点
    if (node->left == NULL) {
        node->left = pre;
        node->lTag = 1;
    }
    // 如果前驱节点的右指针为空，将其指向当前节点
    if (pre != NULL && pre->right == NULL) {
        pre->right = node;
        pre->rTag = 1;
    }
    // 更新前驱节点
    pre = node;

    // 线索化右子树
    inThreading(node->right);
}

// 创建线索二叉树
ThreadedNode* createThreadedTree(ThreadedNode* root) {
    pre = NULL;               // 初始化前驱节点
    inThreading(root);        // 对树进行中序线索化
    return root;
}
```

**中序遍历线索二叉树**

中序遍历线索二叉树不需要栈或递归。通过线索直接访问节点的前驱和后继，可以更高效地遍历。

```c
void inOrder(ThreadedNode *root) {
    ThreadedNode *node = root;
    // 找到最左侧的节点
    while (node != NULL && node->lTag == 0) {
        node = node->left;
    }
    
    while (node != NULL) {
        printf("%d ", node->data);

        // 如果右线索存在，直接跳到后继节点
        if (node->rTag == 1) {
            node = node->right;
        } else {
            // 否则，找到右子树中最左侧的节点
            node = node->right;
            while (node != NULL && node->lTag == 0) {
                node = node->left;
            }
        }
    }
}
```

### 2.13 B树

**B树**（B-tree）是一种自平衡的多路查找树，常用于数据库和文件系统等需要大量存储和快速访问的场合。B树通过在节点中存储多个关键字和指向子树的指针，减少了树的高度，从而提高了查找、插入和删除操作的效率。

**B树的基本概念**

B树是一种平衡多路查找树，具有以下特性：

1. **多路节点**
   - B树的每个节点可以存储多个关键字和多个子树指针，因此B树的分支因子（阶）比二叉树更高。对于阶为`m`的B树，每个节点最多有`m`个子节点和`m-1`个关键字。
2. **节点关键字的有序性**
   - 每个节点中的关键字按升序排列，且节点中的关键字分隔了子节点，使得每个子树中的所有关键字都位于某个区间内。
3. **平衡性**
   - B树是一种高度平衡的树，所有叶子节点都在同一层上。因此从根节点到任何叶子节点的路径长度相同。
4. **节点关键字数量的限制**
   - B树的每个节点至少包含`ceil(m/2)-1`个关键字，最多包含`m-1`个关键字（`m`是B树的阶）。

**B树的性质**

1. **每个节点最多有 `m` 个子节点。**
2. **非叶子节点至少有 `ceil(m/2)` 个子节点。**
3. **根节点至少有 2 个子节点（除非树为空或只有一个节点）。**
4. **所有叶子节点在同一层上。**

这些性质保证了B树的平衡性和较少的高度，使得查找、插入、删除等操作的时间复杂度接近O(log n)。

**B树的操作**

**1. 查找操作**

查找操作与二叉查找树类似，但需要遍历节点中的多个关键字。具体步骤如下：

- 从根节点开始，对每个节点中存储的关键字进行二分查找。
- 如果关键字在当前节点中，则查找成功。
- 如果关键字不在当前节点中，根据关键字的大小选择合适的子树指针，递归进行查找。
- 如果遍历完整棵树未找到，说明查找失败。

**2. 插入操作**

B树的插入操作需要保证所有节点的关键字数量限制，因此插入时可能会导致节点分裂：

- 从根节点开始，找到插入位置的叶子节点。
- 如果叶子节点的关键字数量小于最大允许值，直接插入。
- 如果叶子节点已满（关键字数量等于 `m-1`），则需要分裂该节点，将中间关键字提升到父节点，并将当前节点分裂为两个节点。
- 如果父节点也满，则递归向上分裂，直到根节点。若根节点也需要分裂，会生成一个新的根节点，树的高度增加。

**3. 删除操作**

B树的删除操作比插入操作稍复杂，涉及到节点的合并或关键字的借用以维持B树的平衡性。具体步骤如下：

- 找到要删除的关键字，若在叶节点中，直接删除。
- 若在非叶节点中，用其后继或前驱关键字替换该关键字，并递归删除后继或前驱节点中的关键字。
- 若删除后节点关键字数量小于最小限制，则需要从相邻兄弟节点借关键字，或将当前节点与相邻兄弟节点合并，可能递归影响父节点。
- 若根节点只有一个子节点且删除后为空，则将该子节点提升为新的根节点，减少树的高度。

**B树的应用**

由于B树的平衡性和节点存储多个关键字的特性，它广泛应用于以下领域：

1. **数据库系统**：B树和B+树常用于数据库索引，以加速数据的查找和范围查询。
2. **文件系统**：许多文件系统使用B树来管理文件目录结构，以减少磁盘访问次数。
3. **键值存储**：在键值存储系统中，B树用于高效地存储和检索键值对。

**B树和B+树的区别**

- **B+树**是B树的变种，所有关键字均存储在叶节点中，内部节点仅用作索引。
- B+树的叶节点通过链表连接，支持快速范围查询。
- B树的内部节点存储实际数据，而B+树的内部节点只存储索引信息。

**完整代码：**

```c
#include <stdio.h>
#include <stdlib.h>

#define M 3  // B树的阶数

// 定义B树节点
typedef struct BTreeNode {
    int keys[M - 1];                     // 关键字数组
    struct BTreeNode* children[M];       // 子节点指针数组
    int n;                               // 当前关键字数量
    int isLeaf;                          // 是否为叶子节点
} BTreeNode;

// 创建节点
BTreeNode* createNode(int isLeaf) {
    BTreeNode* node = (BTreeNode*)malloc(sizeof(BTreeNode));
    node->isLeaf = isLeaf;
    node->n = 0;
    for (int i = 0; i < M; i++) {
        node->children[i] = NULL;
    }
    return node;
}

// 查找关键字
BTreeNode* search(BTreeNode* root, int key) {
    int i = 0;

    // 找到第一个大于或等于 key 的位置
    while (i < root->n && key > root->keys[i]) {
        i++;
    }

    // 如果找到关键字，返回节点
    if (i < root->n && key == root->keys[i]) {
        return root;
    }

    // 如果是叶子节点，返回NULL（查找失败）
    if (root->isLeaf) {
        return NULL;
    }

    // 递归在子树中查找
    return search(root->children[i], key);
}

// 分裂子节点
void splitChild(BTreeNode* parent, int i, BTreeNode* child) {
    // 创建一个新的节点，作为child的右半部分
    BTreeNode* newNode = createNode(child->isLeaf);
    newNode->n = M / 2;

    // 把 child 的右半部分关键字和子节点复制到 newNode 中
    for (int j = 0; j < M / 2; j++) {
        newNode->keys[j] = child->keys[j + M / 2];
    }

    if (!child->isLeaf) {
        for (int j = 0; j <= M / 2; j++) {
            newNode->children[j] = child->children[j + M / 2];
        }
    }

    child->n = M / 2 - 1;

    // 将 newNode 插入到 parent 的子节点指针中
    for (int j = parent->n; j >= i + 1; j--) {
        parent->children[j + 1] = parent->children[j];
    }
    parent->children[i + 1] = newNode;

    // 把 child 的中间关键字提升到 parent 中
    for (int j = parent->n - 1; j >= i; j--) {
        parent->keys[j + 1] = parent->keys[j];
    }
    parent->keys[i] = child->keys[M / 2 - 1];
    parent->n++;
}

// 插入非满节点
void insertNonFull(BTreeNode* node, int key) {
    int i = node->n - 1;

    // 如果是叶子节点，直接插入
    if (node->isLeaf) {
        while (i >= 0 && key < node->keys[i]) {
            node->keys[i + 1] = node->keys[i];
            i--;
        }
        node->keys[i + 1] = key;
        node->n++;
    } else {
        // 查找插入位置
        while (i >= 0 && key < node->keys[i]) {
            i--;
        }
        i++;

        // 如果子节点已满，先分裂
        if (node->children[i]->n == M - 1) {
            splitChild(node, i, node->children[i]);
            if (key > node->keys[i]) {
                i++;
            }
        }
        insertNonFull(node->children[i], key);
    }
}

// 插入关键字
void insert(BTreeNode** root, int key) {
    BTreeNode* r = *root;
    if (r->n == M - 1) {
        // 如果根节点已满，创建新根并分裂
        BTreeNode* newRoot = createNode(0);
        newRoot->children[0] = r;
        splitChild(newRoot, 0, r);
        *root = newRoot;
    }
    insertNonFull(*root, key);
}

// 中序遍历B树
void inOrder(BTreeNode* node) {
    if (node != NULL) {
        for (int i = 0; i < node->n; i++) {
            // 递归遍历左子树
            if (!node->isLeaf) {
                inOrder(node->children[i]);
            }
            // 打印当前节点的关键字
            printf("%d ", node->keys[i]);
        }
        // 递归遍历右子树
        if (!node->isLeaf) {
            inOrder(node->children[node->n]);
        }
    }
}

// 主函数
int main() {
    BTreeNode* root = createNode(1);  // 创建空的B树，初始为叶子节点

    // 插入关键字
    insert(&root, 10);
    insert(&root, 20);
    insert(&root, 5);
    insert(&root, 6);
    insert(&root, 12);
    insert(&root, 30);
    insert(&root, 7);
    insert(&root, 17);

    // 查找关键字
    int key = 6;
    BTreeNode* result = search(root, key);
    if (result != NULL) {
        printf("关键字 %d 存在于B树中。\n", key);
    } else {
        printf("关键字 %d 不存在于B树中。\n", key);
    }

    // 中序遍历B树
    printf("B树的中序遍历结果: ");
    inOrder(root);
    printf("\n");

    return 0;
}
```

## 3.哈希表

哈希表（Hash Table），也叫散列表，是一种常用的数据结构，它能以常数时间复杂度（O(1)）进行查找、插入和删除操作。哈希表通过一个称为哈希函数的函数，将键映射到对应的值，进而实现高效的数据存储与检索。

#### 1. **基本概念**

- **键值对（Key-Value Pair）**：哈希表中的数据通常以键值对的形式存储。每个键都唯一地标识表中的一个值。
- **哈希函数（Hash Function）**：哈希函数是哈希表的核心。它接受一个输入（键）并返回一个整数值，称为哈希值（hash value）。该哈希值通常用于计算键在哈希表中的位置。
- **哈希值（Hash Value）**：通过哈希函数计算出的值，用于决定数据的存储位置。
- **冲突（Collision）**：由于哈希表的大小有限，可能会出现不同的键映射到同一个哈希值的情况。这种现象称为冲突。

#### 2. **哈希表的结构**

哈希表通常由以下部分组成：

- **数组**：哈希表底层通常是一个固定大小的数组。哈希函数的输出用于确定数组中的索引位置。
- **哈希函数**：负责将键转换为数组的索引。
- **处理冲突的机制**：当两个或多个键映射到同一个索引时，哈希表需要解决冲突。常见的冲突解决方法有链地址法和开放寻址法。

#### 3. **哈希函数**

哈希函数的好坏直接影响哈希表的性能。一个好的哈希函数应具备以下特点：

- **均匀性**：能将输入的键均匀地分布在哈希表的所有位置，避免大量键映射到相同的哈希值。
- **确定性**：相同的输入必须产生相同的哈希值。
- **高效性**：哈希函数的计算应尽可能高效，避免复杂的计算过程。

#### 4. **哈希冲突与解决方法**

由于哈希表的大小有限，冲突是不可避免的。常见的冲突解决方法有：

- **链地址法（Separate Chaining）**：每个哈希表的元素是一个链表。如果多个键映射到同一个哈希值，则它们会被存储在该哈希位置的链表中。

  优点：容易处理扩展，链表长度可动态增长。

  缺点：如果冲突严重，链表长度增长，查找效率可能退化到 O(n)。

- **开放寻址法（Open Addressing）**：当冲突发生时，寻找表中另一个未使用的空间存放冲突的键。常见的开放寻址方法有：

  - **线性探测（Linear Probing）**：如果某个位置已被占用，则按顺序检查下一个位置，直到找到空闲位置。
  - **二次探测（Quadratic Probing）**：与线性探测类似，但不是顺序探测，而是按二次函数增长（例如，第 1 次检查下一个位置，第 2 次检查位置 +4，依次类推）。
  - **双重哈希（Double Hashing）**：使用另一个哈希函数来决定冲突发生时新的查找步长。

#### 5. **哈希表的性能**

哈希表的性能依赖于以下几个因素：

- **负载因子（Load Factor）**：负载因子是哈希表中元素的数量与哈希表容量的比值。通常负载因子越大，发生冲突的概率越高。为了确保高效的操作，哈希表在负载因子达到一定阈值时通常会进行扩展（即扩大数组的大小）。

  负载因子的计算公式为：

  负载因子=元素个数哈希表大小\text{负载因子} = \frac{\text{元素个数}}{\text{哈希表大小}}负载因子=哈希表大小元素个数

- **扩展（Rehashing）**：当负载因子超过一定值时，哈希表需要进行扩展。扩展时，通常会创建一个新的更大的哈希表，并将旧表中的元素重新计算哈希值插入新表。这是一种较为昂贵的操作，但扩展可以降低冲突的概率，从而提高性能。

#### 6. **哈希表的时间复杂度**

- **平均时间复杂度**：哈希表在良好的哈希函数和较低的负载因子下，查找、插入和删除的时间复杂度都可以达到 O(1)。
- **最坏时间复杂度**：在极端情况下（例如，所有键都映射到同一个哈希值，链表变得很长），查找、插入和删除的时间复杂度可能会退化到 O(n)。

#### 7.哈希表的实现

```c
#include <stdio.h>
#include <stdlib.h>

// 定义链表节点结构
typedef struct HashNode {
    int key;
    int value;
    struct HashNode* next;
} HashNode;

// 定义哈希表结构
typedef struct HashTable {
    int size;
    HashNode** table;
} HashTable;

// 创建一个新节点
HashNode* createNode(int key, int value) {
    HashNode* newNode = (HashNode*)malloc(sizeof(HashNode));
    newNode->key = key;
    newNode->value = value;
    newNode->next = NULL;
    return newNode;
}

// 哈希函数
int hashFunction(int key, int tableSize) {
    return key % tableSize;
}

// 初始化哈希表
HashTable* createHashTable(int size) {
    HashTable* hashTable = (HashTable*)malloc(sizeof(HashTable));
    hashTable->size = size;
    hashTable->table = (HashNode**)malloc(size * sizeof(HashNode*));
    for (int i = 0; i < size; i++) {
        hashTable->table[i] = NULL;
    }
    return hashTable;
}

// 插入键值对到哈希表
void insert(HashTable* hashTable, int key, int value) {
    int hashIndex = hashFunction(key, hashTable->size);
    HashNode* newNode = createNode(key, value);
    
    // 插入节点到链表头部
    if (hashTable->table[hashIndex] == NULL) {
        hashTable->table[hashIndex] = newNode;
    } else {
        newNode->next = hashTable->table[hashIndex];
        hashTable->table[hashIndex] = newNode;
    }
}

// 查找键值对
int search(HashTable* hashTable, int key) {
    int hashIndex = hashFunction(key, hashTable->size);
    HashNode* node = hashTable->table[hashIndex];
    
    // 遍历链表寻找键
    while (node != NULL) {
        if (node->key == key) {
            return node->value;
        }
        node = node->next;
    }
    return -1; // 未找到返回 -1
}

// 删除键值对
void delete(HashTable* hashTable, int key) {
    int hashIndex = hashFunction(key, hashTable->size);
    HashNode* node = hashTable->table[hashIndex];
    HashNode* prev = NULL;
    
    while (node != NULL && node->key != key) {
        prev = node;
        node = node->next;
    }
    
    if (node == NULL) {
        printf("Key not found\n");
        return;
    }
    
    if (prev == NULL) {
        hashTable->table[hashIndex] = node->next;
    } else {
        prev->next = node->next;
    }
    
    free(node);
    printf("Key %d deleted\n", key);
}

// 释放哈希表内存
void freeHashTable(HashTable* hashTable) {
    for (int i = 0; i < hashTable->size; i++) {
        HashNode* node = hashTable->table[i];
        while (node != NULL) {
            HashNode* temp = node;
            node = node->next;
            free(temp);
        }
    }
    free(hashTable->table);
    free(hashTable);
}

// 主函数示例
int main() {
    HashTable* hashTable = createHashTable(10);
    
    insert(hashTable, 1, 100);
    insert(hashTable, 2, 200);
    insert(hashTable, 11, 1100);  // 冲突
    
    printf("Search key 1: %d\n", search(hashTable, 1));
    printf("Search key 11: %d\n", search(hashTable, 11));
    
    delete(hashTable, 1);
    printf("Search key 1 after deletion: %d\n", search(hashTable, 1));
    
    freeHashTable(hashTable);
    
    return 0;
}
```

## 4.图

“图”是一种非常重要的数据结构，用于表示元素之间的关系。它不仅广泛应用于计算机科学中（如网络结构、社交网络分析），也在许多现实世界的场景中有所应用。图由**顶点（或节点）\**和\**边**组成，用来表示不同对象之间的连接关系。接下来，我将逐步介绍图的基本概念、分类、表示方法、图遍历和常用算法。

### 1. 图的基本概念

- **顶点（Vertex）**：图的基本元素，通常用字母（如 A, B, C）表示。
- **边（Edge）**：连接两个顶点的线，表示两个顶点之间的关系。
- **无向图（Undirected Graph）**：如果图中的边是无方向的，表示两个顶点之间可以相互到达，则称为无向图。
- **有向图（Directed Graph）**：如果图中的边有方向，从一个顶点指向另一个顶点，则称为有向图。
- **权重（Weight）**：如果边上有一个数值，用来表示两个顶点之间的某种度量（如距离、费用），称为加权图。

### 2. 图的术语

- **度（Degree）**：节点的连接数目。在无向图中，度是指一个节点连接的边数；在有向图中，分为**入度（In-degree）\**和\**出度（Out-degree）**。
- **路径（Path）**：从一个顶点到另一个顶点的边序列。
- **简单路径**：没有重复顶点的路径。
- **环（Cycle）**：从某个顶点出发经过若干边又回到原顶点。
- **连通图**：对于无向图，如果从任一顶点都能找到到达其他任一顶点的路径，则称该图为连通图。
- **连通分量**：连通子图的最大集合。
- **强连通图**：在有向图中，如果每个顶点都能通过有向路径到达其他顶点，则该图是强连通图。

### 3. 图的表示方法

图通常有两种表示方法：

1. **邻接矩阵（Adjacency Matrix）**：
   - 使用一个二维数组表示图中顶点之间的连接关系。
   - 如果有边存在，则矩阵中对应位置为 1（或权重值），否则为 0。
   - 优点：查找两个顶点是否相邻很方便。
   - 缺点：如果图很稀疏（边很少），则会浪费大量空间。
2. **邻接表（Adjacency List）**：
   - 使用链表或数组列表来表示每个顶点的相邻顶点。
   - 每个顶点有一个链表，链表中存储与之相邻的所有顶点。
   - 优点：节省空间，更适合稀疏图。
   - 缺点：查找两个顶点是否相邻比较耗时。

C 语言实现邻接矩阵表示图

```c
#include <stdio.h>

#define MAX_VERTICES 10

typedef struct Graph {
    int numVertices;  // 顶点数
    int adjMatrix[MAX_VERTICES][MAX_VERTICES]; // 邻接矩阵
} Graph;

// 初始化图
void initGraph(Graph *graph, int numVertices) {
    graph->numVertices = numVertices;
    for (int i = 0; i < numVertices; i++) {
        for (int j = 0; j < numVertices; j++) {
            graph->adjMatrix[i][j] = 0; // 初始化为无边
        }
    }
}

// 添加边
void addEdge(Graph *graph, int src, int dest) {
    graph->adjMatrix[src][dest] = 1;
    graph->adjMatrix[dest][src] = 1; // 无向图，所以对称连接
}

// 打印邻接矩阵
void printGraph(Graph *graph) {
    for (int i = 0; i < graph->numVertices; i++) {
        for (int j = 0; j < graph->numVertices; j++) {
            printf("%d ", graph->adjMatrix[i][j]);
        }
        printf("\n");
    }
}

int main() {
    Graph graph;
    initGraph(&graph, 5);

    addEdge(&graph, 0, 1);
    addEdge(&graph, 0, 4);
    addEdge(&graph, 1, 2);
    addEdge(&graph, 1, 3);
    addEdge(&graph, 1, 4);
    addEdge(&graph, 2, 3);
    addEdge(&graph, 3, 4);

    printf("Adjacency Matrix:\n");
    printGraph(&graph);

    return 0;
}
```

在上述代码中，我们定义了一个图的数据结构 `Graph`，使用一个二维数组来表示邻接矩阵，并实现了初始化图和添加边的方法。

C 语言实现邻接表表示图

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 10

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

typedef struct Graph {
    int numVertices;  // 顶点数
    Node* adjLists[MAX_VERTICES]; // 邻接表
} Graph;

// 创建新节点
Node* createNode(int vertex) {
    Node* newNode = malloc(sizeof(Node));
    newNode->vertex = vertex;
    newNode->next = NULL;
    return newNode;
}

// 初始化图
void initGraph(Graph* graph, int numVertices) {
    graph->numVertices = numVertices;
    for (int i = 0; i < numVertices; i++) {
        graph->adjLists[i] = NULL; // 初始化邻接表为空
    }
}

// 添加边
void addEdge(Graph* graph, int src, int dest) {
    Node* newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;

    // 无向图：对称地添加边
    newNode = createNode(src);
    newNode->next = graph->adjLists[dest];
    graph->adjLists[dest] = newNode;
}

// 打印邻接表
void printGraph(Graph* graph) {
    for (int i = 0; i < graph->numVertices; i++) {
        Node* temp = graph->adjLists[i];
        printf("Vertex %d: ", i);
        while (temp) {
            printf("%d -> ", temp->vertex);
            temp = temp->next;
        }
        printf("NULL\n");
    }
}

int main() {
    Graph graph;
    initGraph(&graph, 5);

    addEdge(&graph, 0, 1);
    addEdge(&graph, 0, 4);
    addEdge(&graph, 1, 2);
    addEdge(&graph, 1, 3);
    addEdge(&graph, 1, 4);
    addEdge(&graph, 2, 3);
    addEdge(&graph, 3, 4);

    printf("Adjacency List:\n");
    printGraph(&graph);

    return 0;
}
```

在这个代码中，我们使用链表表示每个顶点的相邻节点。函数 `createNode` 用于创建一个新的节点，`initGraph` 初始化图，`addEdge` 添加边，`printGraph` 用于打印邻接表。

### 4.图的遍历方法

#### 2.1 深度优先搜索（DFS）

深度优先搜索类似于树的先序遍历，可以使用递归来实现。

**C 语言实现 DFS**

```c
void DFS(Graph* graph, int vertex, int visited[]) {
    visited[vertex] = 1; // 标记节点为已访问
    printf("%d ", vertex);

    Node* temp = graph->adjLists[vertex];
    while (temp != NULL) {
        int adjVertex = temp->vertex;
        if (!visited[adjVertex]) {
            DFS(graph, adjVertex, visited);
        }
        temp = temp->next;
    }
}

int main() {
    Graph graph;
    initGraph(&graph, 5);

    addEdge(&graph, 0, 1);
    addEdge(&graph, 0, 4);
    addEdge(&graph, 1, 2);
    addEdge(&graph, 1, 3);
    addEdge(&graph, 1, 4);
    addEdge(&graph, 2, 3);
    addEdge(&graph, 3, 4);

    int visited[MAX_VERTICES] = {0};

    printf("DFS starting from vertex 0:\n");
    DFS(&graph, 0, visited);

    return 0;
}
```

#### 2.2 广度优先搜索（BFS）

广度优先搜索使用队列逐层访问节点。

**C 语言实现 BFS**

```c
#include <stdbool.h>

void BFS(Graph* graph, int startVertex) {
    bool visited[MAX_VERTICES] = {false};
    int queue[MAX_VERTICES];
    int front = 0, rear = 0;

    visited[startVertex] = true;
    queue[rear++] = startVertex;

    while (front < rear) {
        int currentVertex = queue[front++];
        printf("%d ", currentVertex);

        Node* temp = graph->adjLists[currentVertex];
        while (temp) {
            int adjVertex = temp->vertex;
            if (!visited[adjVertex]) {
                visited[adjVertex] = true;
                queue[rear++] = adjVertex;
            }
            temp = temp->next;
        }
    }
}

int main() {
    Graph graph;
    initGraph(&graph, 5);

    addEdge(&graph, 0, 1);
    addEdge(&graph, 0, 4);
    addEdge(&graph, 1, 2);
    addEdge(&graph, 1, 3);
    addEdge(&graph, 1, 4);
    addEdge(&graph, 2, 3);
    addEdge(&graph, 3, 4);

    printf("BFS starting from vertex 0:\n");
    BFS(&graph, 0);

    return 0;
}
```

在 BFS 中，我们使用一个数组 `queue` 作为队列来存储需要访问的节点。每次从队列中取出一个节点，并将其相邻未访问的节点加入队列。

### 5. **Dijkstra算法**

#### 适用场景

- 解决单源最短路径问题。
- 图中边的权重为非负数。
- 适用于稀疏图。

#### 算法思想

通过贪心思想，从起始点开始，逐步确定从起始点到每个点的最短路径。

#### 实现步骤

1. 初始化：
   - 设定一个数组 `dist[]`，记录从起点到每个顶点的最短距离，初始为无穷大（`inf`），起点的距离为 0。
   - 用一个集合 `S` 表示已经确定最短路径的节点。
2. 选择当前最短路径的节点：
   - 在 `dist[]` 中找到不在 `S` 中且距离最小的节点 `u`，将其加入集合 `S`。
3. 更新邻接点的距离：
   - 遍历节点 `u` 的所有邻接点 `v`，如果经过 `u` 到达 `v` 的路径比当前记录的 `dist[v]` 更短，则更新 `dist[v]`。
4. **重复步骤 2 和 3**，直到所有节点都被加入集合 `S` 或最短路径确定。

#### 时间复杂度

- 使用邻接矩阵表示图：O(V²)，其中 V 是节点数。
- 使用优先队列优化（如最小堆）：O((V + E)logV)，其中 E 是边数。

#### 实现

```c
#include <stdio.h>
#include <limits.h>

#define V 5  // 节点数
#define INF INT_MAX

// 找到未访问节点中距离最小的节点
int minDistance(int dist[], int visited[]) {
    int min = INF, minIndex;

    for (int v = 0; v < V; v++) {
        if (!visited[v] && dist[v] <= min) {
            min = dist[v];
            minIndex = v;
        }
    }
    return minIndex;
}

// Dijkstra算法
void dijkstra(int graph[V][V], int src) {
    int dist[V];     // 最短距离数组
    int visited[V];  // 访问状态数组

    // 初始化
    for (int i = 0; i < V; i++) {
        dist[i] = INF;
        visited[i] = 0;
    }
    dist[src] = 0;

    // 主算法循环
    for (int count = 0; count < V - 1; count++) {
        int u = minDistance(dist, visited);  // 找到未访问节点中最短距离的点
        visited[u] = 1;  // 标记为已访问

        // 更新u的邻接点的距离
        for (int v = 0; v < V; v++) {
            if (!visited[v] && graph[u][v] && dist[u] != INF && dist[u] + graph[u][v] < dist[v]) {
                dist[v] = dist[u] + graph[u][v];
            }
        }
    }

    // 输出结果
    printf("Vertex\tDistance from Source\n");
    for (int i = 0; i < V; i++) {
        printf("%d\t%d\n", i, dist[i]);
    }
}

// 主函数
int main() {
    int graph[V][V] = {
        {0, 10, 20, 0, 0},
        {10, 0, 0, 50, 10},
        {20, 0, 0, 20, 33},
        {0, 50, 20, 0, 2},
        {0, 10, 33, 2, 0}
    };

    dijkstra(graph, 0);
    return 0;
}
```

### 6. **Bellman-Ford算法**

#### 适用场景

- 解决单源最短路径问题。
- 图中允许存在负权边，但不能有负权环（否则路径值会无限减小）。
- 适用于稀疏图。

#### 算法思想

通过动态规划思想，逐步松弛边的权重，找到所有从起点到其他顶点的最短路径。

#### 实现步骤

1. 初始化：
   - 距离数组 `dist[]`，起点到自身为 0，其余为无穷大（`inf`）。
2. 松弛操作：
   - 对每条边 `(u, v)`，如果 `dist[u] + weight < dist[v]`，则更新 `dist[v] = dist[u] + weight`。
   - 重复此操作 **V-1 次**（V 是节点数）。
3. 检查负权环：
   - 再对所有边执行一次松弛操作，如果发现某条边仍然可以被松弛，说明存在负权环。

#### 时间复杂度

- O(VE)，其中 V 是节点数，E 是边数。

#### 实现

```c
#include <stdio.h>
#include <limits.h>

#define V 5
#define E 8
#define INF INT_MAX

struct Edge {
    int src, dest, weight;
};

// Bellman-Ford算法
void bellmanFord(struct Edge edges[], int numEdges, int src) {
    int dist[V];

    // 初始化距离
    for (int i = 0; i < V; i++) {
        dist[i] = INF;
    }
    dist[src] = 0;

    // 松弛操作
    for (int i = 1; i <= V - 1; i++) {
        for (int j = 0; j < numEdges; j++) {
            int u = edges[j].src;
            int v = edges[j].dest;
            int weight = edges[j].weight;

            if (dist[u] != INF && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
            }
        }
    }

    // 检测负权环
    for (int i = 0; i < numEdges; i++) {
        int u = edges[i].src;
        int v = edges[i].dest;
        int weight = edges[i].weight;

        if (dist[u] != INF && dist[u] + weight < dist[v]) {
            printf("Graph contains negative weight cycle\n");
            return;
        }
    }

    // 输出结果
    printf("Vertex\tDistance from Source\n");
    for (int i = 0; i < V; i++) {
        printf("%d\t%d\n", i, dist[i]);
    }
}

// 主函数
int main() {
    struct Edge edges[E] = {
        {0, 1, -1}, {0, 2, 4}, {1, 2, 3}, {1, 3, 2},
        {1, 4, 2}, {3, 2, 5}, {3, 1, 1}, {4, 3, -3}
    };

    bellmanFord(edges, E, 0);
    return 0;
}
```

### 7.**Floyd-Warshall算法**

#### 适用场景

- 解决多源最短路径问题，即计算任意两个顶点之间的最短路径。
- 图中允许有负权边，但不能有负权环。
- 适用于稠密图。

#### 算法思想

通过动态规划思想，不断尝试通过中间顶点更新任意两点间的最短路径。

#### 实现步骤

1. 初始化：
   - 创建一个二维数组 `dist[][]`，初始值为无穷大（`inf`），如果有直接边相连，则将 `dist[i][j]` 设置为边权重；`dist[i][i] = 0`。
2. 逐步优化：
   - 遍历所有可能的中间节点 `k`，尝试通过 `k` 优化任意两点之间的距离。
   - 更新规则为：`dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])`。
3. 完成更新后：
   - `dist[i][j]` 即为从 `i` 到 `j` 的最短路径距离。

#### 时间复杂度

- O(V³)，其中 V 是节点数。

#### 实现

```c
#include <stdio.h>
#define V 4
#define INF 99999

void floydWarshall(int graph[V][V]) {
    int dist[V][V];

    // 初始化距离矩阵
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            dist[i][j] = graph[i][j];
        }
    }

    // 核心算法
    for (int k = 0; k < V; k++) {
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                if (dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }

    // 输出结果
    printf("Shortest distances between every pair of vertices:\n");
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            if (dist[i][j] == INF) {
                printf("%7s", "INF");
            } else {
                printf("%7d", dist[i][j]);
            }
        }
        printf("\n");
    }
}

// 主函数
int main() {
    int graph[V][V] = {
        {0, 3, INF, 5},
        {2, 0, INF, 4},
        {INF, 1, 0, INF},
        {INF, INF, 2, 0}
    };

    floydWarshall(graph);
    return 0;
}
```

